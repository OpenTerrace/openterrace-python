{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"citing/","title":"Citing OpenTerrace","text":"<p>If you use this software in your work, please cite this article:</p> <p>Citation</p> <p><code>H\u00e6rvig, J. (2024). OpenTerrace: A fast, flexible and extendable Python framework for thermal energy storage packed bed simulations. Journal of Open Source Software, 9(98), 6411. https://doi.org/10.21105/joss.06411</code></p> <p>BibTeX entry</p> <p><code>@article{Haervig_OpenTerrace_A_fast_2024, author = {H\u00e6rvig, Jakob}, doi = {10.21105/joss.06411}, journal = {Journal of Open Source Software}, month = jun, number = {98}, pages = {6411}, title = {{OpenTerrace: A fast, flexible and extendable Python framework for thermal energy storage packed bed simulations}}, url = {https://github.com/OpenTerrace/openterrace-python}, volume = {9}, year = {2024}}</code></p>"},{"location":"contact/","title":"Contact","text":"<p>Jakob H\u00e6rvig, Associate Professor (jah@energy.aau.dk)</p> <p>Department of Energy (AAU Energy) Pontoppidanstr\u00e6de 111, 9220-Aalborg East Aalborg University Denmark</p>"},{"location":"contributing/","title":"Contributing","text":"<p>OpenTerrace is all open-source and contributions are most welcome.</p> <ul> <li>Smaller contributions fitting nicely into the existing modelling framework (e.g. a new fluid or bed material). These can be included by a simple pull request to the development branch.</li> <li>Larger contributions requiring revision of existing classes or core functionality. Please reach out beforehand to discuss.</li> </ul>"},{"location":"contributing/#students","title":"Students","text":"<p>Students are invited to help developing OpenTerrace. If you are a student and want to write a semester project within thermal energy storage using OpenTerrace, you are more than welcome to reach out.</p>"},{"location":"installation/","title":"Installation guide","text":"<p>First make sure you have a working installation of Python. If you have never worked with Python before, it's recommended to install Miniconda alongside with the Visual Studio Code text editor. There are two different ways of installing OpenTerrace depending on how you plan to use it.</p>"},{"location":"installation/#install-openterrace-using-pip-for-regular-users","title":"Install OpenTerrace using <code>pip</code> (for regular users)","text":"<pre><code>pip install openterrace\n</code></pre> <p>Pip should resolve all dependencies automatically. For the user interested, a full list of dependencies can be found here. </p>"},{"location":"installation/#install-openterrace-in-editable-mode-for-developers","title":"Install OpenTerrace in editable mode (for developers)","text":""},{"location":"installation/#step-1","title":"Step 1","text":"<p>If you plan on extending or modifying OpenTerrace, you should install it in editable mode, which makes it easier for you to try out new functionality. First, use any git client such as GitHub Desktop to clone the OpenTerrace repository. If you already have Conda installed, you may jump to step 4.</p>"},{"location":"installation/#step-2","title":"Step 2","text":"<p>Next, I recommend using Linux or WSL (if on Windows). Inside a linux terminal do: <pre><code>mkdir -p ~/miniconda3\nwget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -O ~/miniconda3/miniconda.sh\nbash ~/miniconda3/miniconda.sh -b -u -p ~/miniconda3\nrm -rf ~/miniconda3/miniconda.sh\n</code></pre></p>"},{"location":"installation/#step-3","title":"Step 3","text":"<p>Then, initialise your conda environment: <pre><code>~/miniconda3/bin/conda init bash\n</code></pre></p>"},{"location":"installation/#step-4","title":"Step 4","text":"<p>Now, open a terminal and create a virtual environment called <code>ot</code>: <pre><code>conda create -n ot pip python=3.12\n</code></pre></p>"},{"location":"installation/#step-5","title":"Step 5","text":"<p>Activate the virtual environment: <pre><code>conda activate ot\n</code></pre></p>"},{"location":"installation/#step-6","title":"Step 6","text":"<p>Verify that the right pip version is picked up: <pre><code>which pip\n</code></pre> which should give you something like <code>/home/[username]/miniconda3/envs/ot/bin/pip</code></p>"},{"location":"installation/#step-7","title":"Step 7","text":"<p>Finally, install OpenTerrace inside our virtual environment by navigating to the \"openterrace-python\" folder and install in editable mode by: <pre><code>pip install --editable .\n</code></pre></p>"},{"location":"installation/#step-8","title":"Step 8","text":"<p>Verify that the <code>ot</code> virtual environment is picked up as the interpreter in VS Code.</p>"},{"location":"installation/#step-9","title":"Step 9","text":"<p>Now you are ready to run tutorials and modify and extend OpenTerrace as you like.</p>"},{"location":"source_code/","title":"Source code","text":""},{"location":"source_code/#openterrace.Simulate","title":"<code>Simulate</code>","text":"<p>OpenTerrace class.</p> Source code in <code>openterrace/openterrace.py</code> <pre><code>class Simulate:\n    \"\"\"OpenTerrace class.\"\"\"\n\n    def __init__(self, t_start:float=0, t_end:float=None, dt:float=None):\n        \"\"\"Initialise with various control parameters.\n\n        Args:\n            t_start (float): Start time in s\n            t_end (float): End time in s\n            dt (float): Time step size in s\n        \"\"\"\n        self.t_start = t_start\n        self.t_end = t_end\n        self.dt = dt\n        self.coupling = []\n        self.flag_coupling = False\n\n    def create_phase(self, n:int=None, n_other:int=1, type:str=None):\n        \"\"\"Creates a fluid or bed phase.\n\n        Args:\n            n (int): Number of discretisations\n            n_other (int): Number of discretisations of interacting phase. If you are defining a bed phase within a tank. Then n_other is the number of discretisations of the fluid phase.\n            type (str): Phase type\n        \"\"\"\n\n        valid_types = ['fluid','bed']\n        if type not in valid_types:\n            raise Exception(\"Type \\'\"+type+\"\\' specified. Valid options for types are:\", valid_types)\n        return self.Phase(self, n, n_other, type)\n\n    def select_coupling(self, fluid_phase:int=None, bed_phase:int=None, h_exp:str=None, h_value:float=None):\n        \"\"\"Selects coupling of a fluid and bed phase\n\n        Args:\n            fluid_phase (int): phase number\n            bed_phase (int): phase number\n            h_exp (str): Predefined function for convective heat transfer\n            h_value (float): Convective heat transfer coefficient in W/(m^2 K)\n        \"\"\"\n\n        valid_h_exp = ['constant']\n        if h_exp not in valid_h_exp:\n            raise Exception(\"h_exp \\'\"+h_exp+\"\\' specified. Valid options for h_exp are:\", valid_h_exp)\n\n        self.coupling.append({\"fluid_phase\":fluid_phase, \"bed_phase\":bed_phase, \"h_exp\":h_exp, \"h_value\":h_value})\n        self.flag_coupling = True\n\n    def _coupling(self):\n        \"\"\"This is the function that couples the fluid and bed phase.\"\"\"\n        for couple in self.coupling:\n            n_bed = self.Phase.instances[couple['fluid_phase']].domain.V/self.Phase.instances[couple['fluid_phase']].phi*(1-self.Phase.instances[couple['fluid_phase']].phi)/self.Phase.instances[couple['bed_phase']].domain.V0 #ok\n\n            Q = couple['h_value']*self.Phase.instances[couple['bed_phase']].domain.A[-1][-1]*(self.Phase.instances[couple['fluid_phase']].T[0]-self.Phase.instances[couple['bed_phase']].T[:,-1])*self.dt #ok\n\n            self.Phase.instances[couple['bed_phase']].h[:,-1] = self.Phase.instances[couple['bed_phase']].h[:,-1] + Q/(self.Phase.instances[couple['bed_phase']].rho[:,-1] * self.Phase.instances[couple['bed_phase']].domain.V[-1]) #ok\n\n            self.Phase.instances[couple['fluid_phase']].h[0] = self.Phase.instances[couple['fluid_phase']].h[0] - n_bed * Q/(self.Phase.instances[couple['fluid_phase']].rho*self.Phase.instances[couple['fluid_phase']].domain.V) #ok\n\n    def run_simulation(self):\n        \"\"\"If you want to run the simulation, you need to call this function. If data output is specified using the select_output function, the data will live in that specific phase instance. For more details on how to access the data, please refer to the tutorials.\"\"\"\n\n\n        for t in tqdm.tqdm(np.arange(self.t_start, self.t_end+self.dt, self.dt)):\n\n            for phase_instance in self.Phase.instances:\n                phase_instance._save_data(t)\n                phase_instance._solve_equations(t, self.dt)\n                phase_instance._update_properties()\n            if self.flag_coupling:\n                self._coupling()\n    class Phase:\n        instances = []\n        \"\"\"Main class to define either the fluid or bed phase.\"\"\"\n\n        def __init__(self, outer=None, n:int=None, n_other:int=None, type:str=None):\n            \"\"\"Initialise a phase with number of control points and type.\n\n            Args:\n                outer (object): Outer class\n                n (int): Number of discretisations for the given phase\n                n_other (int): Number of discretisations for the other phase\n                type (str): Type of phase\n            \"\"\"\n\n            self.outer = outer\n            self.__class__.instances.append(self)\n            self.n = n\n            self.n_other = n_other\n\n            self.phi = 1\n            self.bcs = []\n            self.sources = []\n\n            self._flag_save_data = False\n            self.type = type\n\n        def select_substance_on_the_fly(self, cp:float=None, rho:float=None, k:float=None):\n            \"\"\"Defines and selects a new substance on-the-fly. This is useful for defining a substance for testing purposes with temperature independent properties.\n\n            Args:\n                cp (float): Specific heat capacity in J/(kg K)\n                rho (float): Density in kg/m^3\n                k (float): Thermal conductivity in W/(m K)\n            \"\"\"\n            class dummy:\n                pass\n            self.fcns = dummy()\n            self.fcns.h = lambda T: np.ones_like(T)*T*cp\n            self.fcns.T = lambda h: np.ones_like(h)*h/cp\n            self.fcns.cp = lambda h: np.ones_like(h)*cp\n            self.fcns.k = lambda h: np.ones_like(h)*k\n            self.fcns.rho = lambda h: np.ones_like(h)*rho\n\n        def select_substance(self, substance:str=None):\n            \"\"\"Selects one of the predefined substancers.\n\n            Args:\n                substance (str): Substance name\n            \"\"\"\n\n            valid_substances = globals()[self.type+'_substances'].__all__\n            if not substance:\n                raise Exception(\"Keyword 'substance' not specified.\")\n            if not substance in valid_substances:\n                raise Exception(substance+\" specified as \"+self.type+\" substance. Valid \"+self.type+\" substances are:\", valid_substances)\n            self.fcns = getattr(globals()[self.type+'_substances'], substance)\n\n        def select_h_coeff(self, h_exp:str=None, value:float=None):\n            \"\"\"Selects an expression for the heat transfer coefficient.\n\n            Args:\n                h_exp (str): Heat transfer coefficient expression\n                value (float): Heat transfer coefficient value\n            \"\"\"\n\n            valid_correlations = ['constant']\n            if correlation not in valid_correlations:\n                raise Exception(\"correlation \\'\"+correlation+\"\\' specified. Valid options for correlation are:\", valid_correlations)\n            self.fcns.h_correlation = getattr(globals()['heat_transfer_correlations'], correlation)\n\n        def select_domain_shape(self, domain:str=None, **kwargs):\n            \"\"\"Select domain shape and initialise constants.\n\n            Args:\n                domain (str): Domain type\n                **kwargs (float): Dimensions of domain to be specified depnding on the domain type\n            \"\"\"\n\n            if not domain:\n                raise Exception(\"Keyword 'domain' not specified.\")\n            if not domain in globals()['domains'].__all__:\n                raise Exception(\"domain \\'\"+domain+\"\\' specified. Valid options for domain are:\", self.valid_domains)\n\n            kwargs['n'] = self.n \n            self.domain = getattr(globals()['domains'], domain)\n            self.domain.type = domain\n            self.domain.validate_input(kwargs, domain)\n            self.domain.shape = self.domain.shape(kwargs)\n            self.domain.dx = self.domain.dx(kwargs)\n            self.domain.A = self.domain.A(kwargs)\n            self.domain.V = self.domain.V(kwargs)\n            self.domain.V0 = self.domain.V0(kwargs)\n            self.node_pos = self.domain.node_pos(kwargs)\n\n        def select_porosity(self, phi:float=1):\n            \"\"\"Select porosity from 0 to 1, e.g. filling the domain with the phase up to a certain degree.\n\n            Args:\n                phi (float): Porosity value\n            \"\"\"\n\n            self.domain.V = self.domain.V*phi\n            self.phi = phi\n\n        def select_schemes(self, diff:str=None, conv:str=None):\n            \"\"\"Imports the specified diffusion and convection schemes.\n\n            Args:\n                diff (str): Differenctial scheme\n                conv (str): Convection scheme\n            \"\"\"\n\n            if self.domain.type == 'lumped':\n                raise Exception(\"'lumped' has been selected as domain type. Please don't specify a discretisation scheme.\")\n\n            if diff is not None:\n                try:\n                    self.diff = getattr(getattr(globals()['diffusion_schemes'], diff), diff)\n                except:\n                    raise Exception(\"Diffusion scheme \\'\"+diff+\"\\' specified. Valid options for diffusion schemes are:\", diffusion_schemes.__all__)\n\n            if conv is not None:\n                try:\n                    self.conv = getattr(getattr(globals()['convection_schemes'], conv), conv)\n                except:\n                    raise Exception(\"Convection scheme \\'\"+conv+\"\\' specified. Valid options for convection schemes are:\", convection_schemes.__all__)\n\n        def select_initial_conditions(self, T:list[float]=None):\n            \"\"\"Initialises temperature field.\n\n            Args:\n                T (float): List of length n with initial temperatures\n            \"\"\"\n\n            if np.array(T).size == 1:\n                self.T = np.tile(T,(np.append(self.n_other,self.domain.shape)))   \n            elif np.array(T).size == self.n:\n                self.T = np.tile(T,(np.append(self.n_other,1)))\n            else: Exception(\"Length of T must be 1 or equal to n\")\n\n            self.h = self.fcns.h(self.T)\n            self.T = self.fcns.T(self.h)\n            self.rho = self.fcns.rho(self.h)\n            self.cp = self.fcns.cp(self.h)\n            self.k = self.fcns.k(self.h)\n            self.D = np.zeros(((2,)+(self.T.shape)))\n            self.F = np.zeros(((2,)+(self.T.shape)))\n            self.S = np.zeros(self.T.shape)\n\n        def select_massflow(self, mdot:list[float]=None):\n            \"\"\"Initialises mass flow rate field.\n\n            Args:\n                mdot (float): Array of mass flow rate. Column 0 is time and column 1 is mass flow rate\n            \"\"\"\n\n            self.mdot_array = np.array(mdot)\n\n        def select_bc(self, bc_type:str=None, parameter:str=None, position=None, value:float=None):\n            \"\"\"Specify boundary condition type.\n\n            Args:\n                bc_type (str): Type of boundary condition\n                parameter (str): Which field it applies to\n                position (int): indices of which cells it applies to\n                value (float): Value of boundary condition\n            \"\"\"\n\n            valid_bc_types = ['fixed_value','zero_gradient']\n            if bc_type not in valid_bc_types:\n                raise Exception(\"bc_type \\'\"+bc_type+\"\\' specified. Valid options for bc_type are:\", valid_bc_types)\n            valid_parameters = ['T','mdot']\n            if parameter not in valid_parameters:\n                raise Exception(\"parameter \\'\"+parameter+\"\\' specified. Valid options for parameter are:\", valid_parameters)\n            if not position:\n                raise Exception(\"Keyword 'position' not specified.\")\n            if value is None and bc_type=='fixed_value':\n                raise Exception(\"Keyword 'value' is needed for fixed_value type bc.\")\n            self.bcs.append({'type': bc_type, 'parameter': parameter, 'position': position, 'value': np.array(value)})\n\n        def add_sourceterm_thermal_resistance(self, R:list[float], T_inf:list[float]):\n            \"\"\"Specify a thermal resistance source term.\n\n            Args:\n                R (float): List of thermal resistances\n                T_inf (float): List of fluid temperatures\n            \"\"\"\n            if not len([R]) in [1,self.n]:\n                raise Exception(\"Length of R must be 1 or equal to n\")\n\n            if not len([T_inf]) in [1,self.n]:\n                raise Exception(\"Length of T_inf must be 1 or equal to n\")\n\n            self.sources.append({'R': R, 'T_inf': T_inf})\n\n        def select_output(self, times:list[float]=None, output_parameters:list[str]=['T']):\n            \"\"\"Specify output times.\n\n            Args:\n                times (float): List of times to output data\n            \"\"\"\n\n            self.output_parameters = output_parameters\n            class Data(object):\n                pass\n            self.data = Data()\n            self.data.time = np.intersect1d(np.array(times), np.arange(self.outer.t_start, self.outer.t_end+self.outer.dt, self.outer.dt))\n            for parameter in output_parameters:\n                setattr(self.data,parameter, np.full((len(self.data.time), self.n_other, self.n),np.nan))\n                self._flag_save_data = True\n                self._q = 0\n\n        def _save_data(self, t:float=None):\n            \"\"\"Save data at specified times.\n\n            Args:\n                t (float): Current time\n            \"\"\"\n\n            if self._flag_save_data:\n                if t in self.data.time:\n                    for parameter in self.output_parameters:\n                        getattr(self.data,parameter)[self._q] = getattr(self,parameter)\n                    self._q = self._q+1\n\n        def _update_massflow_rate(self, t:float):\n            \"\"\"Update mass flow rate at specified times.\n\n            Args:\n                t (float): Current time\n            \"\"\"\n\n            if self.mdot_array.ndim == 0:\n                self.mdot = np.tile(self.mdot_array,(np.append(self.n_other,self.domain.shape)))\n            elif self.mdot_array.ndim == 2:\n                self.mdot = np.interp(t, self.mdot_array[:,0], self.mdot_array[:,1])\n\n        def _update_properties(self):\n            \"\"\"Update properties at each time step.\"\"\"\n\n            self.T = self.fcns.T(self.h)\n            self.rho = self.fcns.rho(self.h)\n            self.cp = self.fcns.cp(self.h)\n\n            if hasattr(self, 'diff'):\n                self.k = self.fcns.k(self.h)\n                self.D[0,:,:] = self.k*self.domain.A[0]/self.domain.dx\n                self.D[1,:,:] = self.k*self.domain.A[1]/self.domain.dx\n\n            if hasattr(self, 'conv'):\n                self.F[0,:,:] = self.mdot*self.cp\n                self.F[1,:,:] = self.mdot*self.cp\n\n        def _update_boundary_nodes(self, t:float=None, dt:float=None):\n            \"\"\"Update boundary nodes.\n\n            Args:\n                t (float): Current time\n                dt (float): Time step size\n            \"\"\"\n\n            for bc in self.bcs:\n                if bc['type'] == 'fixed_value':\n                    self.h[bc['position']] = self.fcns.h(bc['value'])\n                if bc['type'] == 'fixed_value_timevarying':\n                    self.h[bc['position']] = self.fcns.h(np.interp(t,bc['value'][:,0],bc['value'][:,1]))\n                if bc['type'] == 'zero_gradient':\n                    if bc['position'] == np.s_[:,0]:\n                        self.h[bc['position']] = self.h[bc['position']] + (2*self.T[:,1]*self.D[1,:,0] - 2*self.T[:,0]*self.D[1,:,0] - self.F[0,:,1]*self.T[:,1] + self.F[1,:,0]*self.T[:,0]) / (self.rho[:,0]*self.domain.V[0])*dt\n                    if bc['position'] == np.s_[:,-1]:\n                        self.h[bc['position']] = self.h[bc['position']] + (2*self.T[:,-2]*self.D[0,:,-1] - 2*self.T[:,-1]*self.D[0,:,-1] + self.F[1,:,-2]*self.T[:,-2] - self.F[0,:,-1]*self.T[:,-1]) / (self.rho[:,-1]*self.domain.V[-1])*dt\n\n        def _update_source(self, dt:float=None):\n            \"\"\"Update source term.\n\n            Args:\n                dt (float): Time step size\n            \"\"\"\n\n            for source in self.sources:\n                self.h = self.h + (source['T_inf']-self.T)*2 / source['R'] * dt/(self.rho*self.domain.V)\n\n        def _solve_equations(self, t:float=None, dt:float=None):\n            \"\"\"Solve equations at each time step.\n\n            Args:\n                t (float): Current time\n                dt (float): Time step size\n            \"\"\"\n\n            self._update_boundary_nodes(t, dt)\n            if hasattr(self, 'diff'):\n                self.h = self.h + self.diff(self.T, self.D)/(self.rho*self.domain.V)*dt\n            if hasattr(self, 'conv'):\n                self._update_massflow_rate(t)\n                self.h = self.h + self.conv(self.T, self.F)/(self.rho*self.domain.V)*dt\n            if self.sources is not None:\n                self._update_source(dt)\n</code></pre>"},{"location":"source_code/#openterrace.Simulate.Phase","title":"<code>Phase</code>","text":"Source code in <code>openterrace/openterrace.py</code> <pre><code>class Phase:\n    instances = []\n    \"\"\"Main class to define either the fluid or bed phase.\"\"\"\n\n    def __init__(self, outer=None, n:int=None, n_other:int=None, type:str=None):\n        \"\"\"Initialise a phase with number of control points and type.\n\n        Args:\n            outer (object): Outer class\n            n (int): Number of discretisations for the given phase\n            n_other (int): Number of discretisations for the other phase\n            type (str): Type of phase\n        \"\"\"\n\n        self.outer = outer\n        self.__class__.instances.append(self)\n        self.n = n\n        self.n_other = n_other\n\n        self.phi = 1\n        self.bcs = []\n        self.sources = []\n\n        self._flag_save_data = False\n        self.type = type\n\n    def select_substance_on_the_fly(self, cp:float=None, rho:float=None, k:float=None):\n        \"\"\"Defines and selects a new substance on-the-fly. This is useful for defining a substance for testing purposes with temperature independent properties.\n\n        Args:\n            cp (float): Specific heat capacity in J/(kg K)\n            rho (float): Density in kg/m^3\n            k (float): Thermal conductivity in W/(m K)\n        \"\"\"\n        class dummy:\n            pass\n        self.fcns = dummy()\n        self.fcns.h = lambda T: np.ones_like(T)*T*cp\n        self.fcns.T = lambda h: np.ones_like(h)*h/cp\n        self.fcns.cp = lambda h: np.ones_like(h)*cp\n        self.fcns.k = lambda h: np.ones_like(h)*k\n        self.fcns.rho = lambda h: np.ones_like(h)*rho\n\n    def select_substance(self, substance:str=None):\n        \"\"\"Selects one of the predefined substancers.\n\n        Args:\n            substance (str): Substance name\n        \"\"\"\n\n        valid_substances = globals()[self.type+'_substances'].__all__\n        if not substance:\n            raise Exception(\"Keyword 'substance' not specified.\")\n        if not substance in valid_substances:\n            raise Exception(substance+\" specified as \"+self.type+\" substance. Valid \"+self.type+\" substances are:\", valid_substances)\n        self.fcns = getattr(globals()[self.type+'_substances'], substance)\n\n    def select_h_coeff(self, h_exp:str=None, value:float=None):\n        \"\"\"Selects an expression for the heat transfer coefficient.\n\n        Args:\n            h_exp (str): Heat transfer coefficient expression\n            value (float): Heat transfer coefficient value\n        \"\"\"\n\n        valid_correlations = ['constant']\n        if correlation not in valid_correlations:\n            raise Exception(\"correlation \\'\"+correlation+\"\\' specified. Valid options for correlation are:\", valid_correlations)\n        self.fcns.h_correlation = getattr(globals()['heat_transfer_correlations'], correlation)\n\n    def select_domain_shape(self, domain:str=None, **kwargs):\n        \"\"\"Select domain shape and initialise constants.\n\n        Args:\n            domain (str): Domain type\n            **kwargs (float): Dimensions of domain to be specified depnding on the domain type\n        \"\"\"\n\n        if not domain:\n            raise Exception(\"Keyword 'domain' not specified.\")\n        if not domain in globals()['domains'].__all__:\n            raise Exception(\"domain \\'\"+domain+\"\\' specified. Valid options for domain are:\", self.valid_domains)\n\n        kwargs['n'] = self.n \n        self.domain = getattr(globals()['domains'], domain)\n        self.domain.type = domain\n        self.domain.validate_input(kwargs, domain)\n        self.domain.shape = self.domain.shape(kwargs)\n        self.domain.dx = self.domain.dx(kwargs)\n        self.domain.A = self.domain.A(kwargs)\n        self.domain.V = self.domain.V(kwargs)\n        self.domain.V0 = self.domain.V0(kwargs)\n        self.node_pos = self.domain.node_pos(kwargs)\n\n    def select_porosity(self, phi:float=1):\n        \"\"\"Select porosity from 0 to 1, e.g. filling the domain with the phase up to a certain degree.\n\n        Args:\n            phi (float): Porosity value\n        \"\"\"\n\n        self.domain.V = self.domain.V*phi\n        self.phi = phi\n\n    def select_schemes(self, diff:str=None, conv:str=None):\n        \"\"\"Imports the specified diffusion and convection schemes.\n\n        Args:\n            diff (str): Differenctial scheme\n            conv (str): Convection scheme\n        \"\"\"\n\n        if self.domain.type == 'lumped':\n            raise Exception(\"'lumped' has been selected as domain type. Please don't specify a discretisation scheme.\")\n\n        if diff is not None:\n            try:\n                self.diff = getattr(getattr(globals()['diffusion_schemes'], diff), diff)\n            except:\n                raise Exception(\"Diffusion scheme \\'\"+diff+\"\\' specified. Valid options for diffusion schemes are:\", diffusion_schemes.__all__)\n\n        if conv is not None:\n            try:\n                self.conv = getattr(getattr(globals()['convection_schemes'], conv), conv)\n            except:\n                raise Exception(\"Convection scheme \\'\"+conv+\"\\' specified. Valid options for convection schemes are:\", convection_schemes.__all__)\n\n    def select_initial_conditions(self, T:list[float]=None):\n        \"\"\"Initialises temperature field.\n\n        Args:\n            T (float): List of length n with initial temperatures\n        \"\"\"\n\n        if np.array(T).size == 1:\n            self.T = np.tile(T,(np.append(self.n_other,self.domain.shape)))   \n        elif np.array(T).size == self.n:\n            self.T = np.tile(T,(np.append(self.n_other,1)))\n        else: Exception(\"Length of T must be 1 or equal to n\")\n\n        self.h = self.fcns.h(self.T)\n        self.T = self.fcns.T(self.h)\n        self.rho = self.fcns.rho(self.h)\n        self.cp = self.fcns.cp(self.h)\n        self.k = self.fcns.k(self.h)\n        self.D = np.zeros(((2,)+(self.T.shape)))\n        self.F = np.zeros(((2,)+(self.T.shape)))\n        self.S = np.zeros(self.T.shape)\n\n    def select_massflow(self, mdot:list[float]=None):\n        \"\"\"Initialises mass flow rate field.\n\n        Args:\n            mdot (float): Array of mass flow rate. Column 0 is time and column 1 is mass flow rate\n        \"\"\"\n\n        self.mdot_array = np.array(mdot)\n\n    def select_bc(self, bc_type:str=None, parameter:str=None, position=None, value:float=None):\n        \"\"\"Specify boundary condition type.\n\n        Args:\n            bc_type (str): Type of boundary condition\n            parameter (str): Which field it applies to\n            position (int): indices of which cells it applies to\n            value (float): Value of boundary condition\n        \"\"\"\n\n        valid_bc_types = ['fixed_value','zero_gradient']\n        if bc_type not in valid_bc_types:\n            raise Exception(\"bc_type \\'\"+bc_type+\"\\' specified. Valid options for bc_type are:\", valid_bc_types)\n        valid_parameters = ['T','mdot']\n        if parameter not in valid_parameters:\n            raise Exception(\"parameter \\'\"+parameter+\"\\' specified. Valid options for parameter are:\", valid_parameters)\n        if not position:\n            raise Exception(\"Keyword 'position' not specified.\")\n        if value is None and bc_type=='fixed_value':\n            raise Exception(\"Keyword 'value' is needed for fixed_value type bc.\")\n        self.bcs.append({'type': bc_type, 'parameter': parameter, 'position': position, 'value': np.array(value)})\n\n    def add_sourceterm_thermal_resistance(self, R:list[float], T_inf:list[float]):\n        \"\"\"Specify a thermal resistance source term.\n\n        Args:\n            R (float): List of thermal resistances\n            T_inf (float): List of fluid temperatures\n        \"\"\"\n        if not len([R]) in [1,self.n]:\n            raise Exception(\"Length of R must be 1 or equal to n\")\n\n        if not len([T_inf]) in [1,self.n]:\n            raise Exception(\"Length of T_inf must be 1 or equal to n\")\n\n        self.sources.append({'R': R, 'T_inf': T_inf})\n\n    def select_output(self, times:list[float]=None, output_parameters:list[str]=['T']):\n        \"\"\"Specify output times.\n\n        Args:\n            times (float): List of times to output data\n        \"\"\"\n\n        self.output_parameters = output_parameters\n        class Data(object):\n            pass\n        self.data = Data()\n        self.data.time = np.intersect1d(np.array(times), np.arange(self.outer.t_start, self.outer.t_end+self.outer.dt, self.outer.dt))\n        for parameter in output_parameters:\n            setattr(self.data,parameter, np.full((len(self.data.time), self.n_other, self.n),np.nan))\n            self._flag_save_data = True\n            self._q = 0\n\n    def _save_data(self, t:float=None):\n        \"\"\"Save data at specified times.\n\n        Args:\n            t (float): Current time\n        \"\"\"\n\n        if self._flag_save_data:\n            if t in self.data.time:\n                for parameter in self.output_parameters:\n                    getattr(self.data,parameter)[self._q] = getattr(self,parameter)\n                self._q = self._q+1\n\n    def _update_massflow_rate(self, t:float):\n        \"\"\"Update mass flow rate at specified times.\n\n        Args:\n            t (float): Current time\n        \"\"\"\n\n        if self.mdot_array.ndim == 0:\n            self.mdot = np.tile(self.mdot_array,(np.append(self.n_other,self.domain.shape)))\n        elif self.mdot_array.ndim == 2:\n            self.mdot = np.interp(t, self.mdot_array[:,0], self.mdot_array[:,1])\n\n    def _update_properties(self):\n        \"\"\"Update properties at each time step.\"\"\"\n\n        self.T = self.fcns.T(self.h)\n        self.rho = self.fcns.rho(self.h)\n        self.cp = self.fcns.cp(self.h)\n\n        if hasattr(self, 'diff'):\n            self.k = self.fcns.k(self.h)\n            self.D[0,:,:] = self.k*self.domain.A[0]/self.domain.dx\n            self.D[1,:,:] = self.k*self.domain.A[1]/self.domain.dx\n\n        if hasattr(self, 'conv'):\n            self.F[0,:,:] = self.mdot*self.cp\n            self.F[1,:,:] = self.mdot*self.cp\n\n    def _update_boundary_nodes(self, t:float=None, dt:float=None):\n        \"\"\"Update boundary nodes.\n\n        Args:\n            t (float): Current time\n            dt (float): Time step size\n        \"\"\"\n\n        for bc in self.bcs:\n            if bc['type'] == 'fixed_value':\n                self.h[bc['position']] = self.fcns.h(bc['value'])\n            if bc['type'] == 'fixed_value_timevarying':\n                self.h[bc['position']] = self.fcns.h(np.interp(t,bc['value'][:,0],bc['value'][:,1]))\n            if bc['type'] == 'zero_gradient':\n                if bc['position'] == np.s_[:,0]:\n                    self.h[bc['position']] = self.h[bc['position']] + (2*self.T[:,1]*self.D[1,:,0] - 2*self.T[:,0]*self.D[1,:,0] - self.F[0,:,1]*self.T[:,1] + self.F[1,:,0]*self.T[:,0]) / (self.rho[:,0]*self.domain.V[0])*dt\n                if bc['position'] == np.s_[:,-1]:\n                    self.h[bc['position']] = self.h[bc['position']] + (2*self.T[:,-2]*self.D[0,:,-1] - 2*self.T[:,-1]*self.D[0,:,-1] + self.F[1,:,-2]*self.T[:,-2] - self.F[0,:,-1]*self.T[:,-1]) / (self.rho[:,-1]*self.domain.V[-1])*dt\n\n    def _update_source(self, dt:float=None):\n        \"\"\"Update source term.\n\n        Args:\n            dt (float): Time step size\n        \"\"\"\n\n        for source in self.sources:\n            self.h = self.h + (source['T_inf']-self.T)*2 / source['R'] * dt/(self.rho*self.domain.V)\n\n    def _solve_equations(self, t:float=None, dt:float=None):\n        \"\"\"Solve equations at each time step.\n\n        Args:\n            t (float): Current time\n            dt (float): Time step size\n        \"\"\"\n\n        self._update_boundary_nodes(t, dt)\n        if hasattr(self, 'diff'):\n            self.h = self.h + self.diff(self.T, self.D)/(self.rho*self.domain.V)*dt\n        if hasattr(self, 'conv'):\n            self._update_massflow_rate(t)\n            self.h = self.h + self.conv(self.T, self.F)/(self.rho*self.domain.V)*dt\n        if self.sources is not None:\n            self._update_source(dt)\n</code></pre>"},{"location":"source_code/#openterrace.Simulate.Phase.instances","title":"<code>instances = []</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Main class to define either the fluid or bed phase.</p>"},{"location":"source_code/#openterrace.Simulate.Phase.__init__","title":"<code>__init__(outer=None, n=None, n_other=None, type=None)</code>","text":"<p>Initialise a phase with number of control points and type.</p> <p>Parameters:</p> Name Type Description Default <code>outer</code> <code>object</code> <p>Outer class</p> <code>None</code> <code>n</code> <code>int</code> <p>Number of discretisations for the given phase</p> <code>None</code> <code>n_other</code> <code>int</code> <p>Number of discretisations for the other phase</p> <code>None</code> <code>type</code> <code>str</code> <p>Type of phase</p> <code>None</code> Source code in <code>openterrace/openterrace.py</code> <pre><code>def __init__(self, outer=None, n:int=None, n_other:int=None, type:str=None):\n    \"\"\"Initialise a phase with number of control points and type.\n\n    Args:\n        outer (object): Outer class\n        n (int): Number of discretisations for the given phase\n        n_other (int): Number of discretisations for the other phase\n        type (str): Type of phase\n    \"\"\"\n\n    self.outer = outer\n    self.__class__.instances.append(self)\n    self.n = n\n    self.n_other = n_other\n\n    self.phi = 1\n    self.bcs = []\n    self.sources = []\n\n    self._flag_save_data = False\n    self.type = type\n</code></pre>"},{"location":"source_code/#openterrace.Simulate.Phase.add_sourceterm_thermal_resistance","title":"<code>add_sourceterm_thermal_resistance(R, T_inf)</code>","text":"<p>Specify a thermal resistance source term.</p> <p>Parameters:</p> Name Type Description Default <code>R</code> <code>float</code> <p>List of thermal resistances</p> required <code>T_inf</code> <code>float</code> <p>List of fluid temperatures</p> required Source code in <code>openterrace/openterrace.py</code> <pre><code>def add_sourceterm_thermal_resistance(self, R:list[float], T_inf:list[float]):\n    \"\"\"Specify a thermal resistance source term.\n\n    Args:\n        R (float): List of thermal resistances\n        T_inf (float): List of fluid temperatures\n    \"\"\"\n    if not len([R]) in [1,self.n]:\n        raise Exception(\"Length of R must be 1 or equal to n\")\n\n    if not len([T_inf]) in [1,self.n]:\n        raise Exception(\"Length of T_inf must be 1 or equal to n\")\n\n    self.sources.append({'R': R, 'T_inf': T_inf})\n</code></pre>"},{"location":"source_code/#openterrace.Simulate.Phase.select_bc","title":"<code>select_bc(bc_type=None, parameter=None, position=None, value=None)</code>","text":"<p>Specify boundary condition type.</p> <p>Parameters:</p> Name Type Description Default <code>bc_type</code> <code>str</code> <p>Type of boundary condition</p> <code>None</code> <code>parameter</code> <code>str</code> <p>Which field it applies to</p> <code>None</code> <code>position</code> <code>int</code> <p>indices of which cells it applies to</p> <code>None</code> <code>value</code> <code>float</code> <p>Value of boundary condition</p> <code>None</code> Source code in <code>openterrace/openterrace.py</code> <pre><code>def select_bc(self, bc_type:str=None, parameter:str=None, position=None, value:float=None):\n    \"\"\"Specify boundary condition type.\n\n    Args:\n        bc_type (str): Type of boundary condition\n        parameter (str): Which field it applies to\n        position (int): indices of which cells it applies to\n        value (float): Value of boundary condition\n    \"\"\"\n\n    valid_bc_types = ['fixed_value','zero_gradient']\n    if bc_type not in valid_bc_types:\n        raise Exception(\"bc_type \\'\"+bc_type+\"\\' specified. Valid options for bc_type are:\", valid_bc_types)\n    valid_parameters = ['T','mdot']\n    if parameter not in valid_parameters:\n        raise Exception(\"parameter \\'\"+parameter+\"\\' specified. Valid options for parameter are:\", valid_parameters)\n    if not position:\n        raise Exception(\"Keyword 'position' not specified.\")\n    if value is None and bc_type=='fixed_value':\n        raise Exception(\"Keyword 'value' is needed for fixed_value type bc.\")\n    self.bcs.append({'type': bc_type, 'parameter': parameter, 'position': position, 'value': np.array(value)})\n</code></pre>"},{"location":"source_code/#openterrace.Simulate.Phase.select_domain_shape","title":"<code>select_domain_shape(domain=None, **kwargs)</code>","text":"<p>Select domain shape and initialise constants.</p> <p>Parameters:</p> Name Type Description Default <code>domain</code> <code>str</code> <p>Domain type</p> <code>None</code> <code>**kwargs</code> <code>float</code> <p>Dimensions of domain to be specified depnding on the domain type</p> <code>{}</code> Source code in <code>openterrace/openterrace.py</code> <pre><code>def select_domain_shape(self, domain:str=None, **kwargs):\n    \"\"\"Select domain shape and initialise constants.\n\n    Args:\n        domain (str): Domain type\n        **kwargs (float): Dimensions of domain to be specified depnding on the domain type\n    \"\"\"\n\n    if not domain:\n        raise Exception(\"Keyword 'domain' not specified.\")\n    if not domain in globals()['domains'].__all__:\n        raise Exception(\"domain \\'\"+domain+\"\\' specified. Valid options for domain are:\", self.valid_domains)\n\n    kwargs['n'] = self.n \n    self.domain = getattr(globals()['domains'], domain)\n    self.domain.type = domain\n    self.domain.validate_input(kwargs, domain)\n    self.domain.shape = self.domain.shape(kwargs)\n    self.domain.dx = self.domain.dx(kwargs)\n    self.domain.A = self.domain.A(kwargs)\n    self.domain.V = self.domain.V(kwargs)\n    self.domain.V0 = self.domain.V0(kwargs)\n    self.node_pos = self.domain.node_pos(kwargs)\n</code></pre>"},{"location":"source_code/#openterrace.Simulate.Phase.select_h_coeff","title":"<code>select_h_coeff(h_exp=None, value=None)</code>","text":"<p>Selects an expression for the heat transfer coefficient.</p> <p>Parameters:</p> Name Type Description Default <code>h_exp</code> <code>str</code> <p>Heat transfer coefficient expression</p> <code>None</code> <code>value</code> <code>float</code> <p>Heat transfer coefficient value</p> <code>None</code> Source code in <code>openterrace/openterrace.py</code> <pre><code>def select_h_coeff(self, h_exp:str=None, value:float=None):\n    \"\"\"Selects an expression for the heat transfer coefficient.\n\n    Args:\n        h_exp (str): Heat transfer coefficient expression\n        value (float): Heat transfer coefficient value\n    \"\"\"\n\n    valid_correlations = ['constant']\n    if correlation not in valid_correlations:\n        raise Exception(\"correlation \\'\"+correlation+\"\\' specified. Valid options for correlation are:\", valid_correlations)\n    self.fcns.h_correlation = getattr(globals()['heat_transfer_correlations'], correlation)\n</code></pre>"},{"location":"source_code/#openterrace.Simulate.Phase.select_initial_conditions","title":"<code>select_initial_conditions(T=None)</code>","text":"<p>Initialises temperature field.</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>float</code> <p>List of length n with initial temperatures</p> <code>None</code> Source code in <code>openterrace/openterrace.py</code> <pre><code>def select_initial_conditions(self, T:list[float]=None):\n    \"\"\"Initialises temperature field.\n\n    Args:\n        T (float): List of length n with initial temperatures\n    \"\"\"\n\n    if np.array(T).size == 1:\n        self.T = np.tile(T,(np.append(self.n_other,self.domain.shape)))   \n    elif np.array(T).size == self.n:\n        self.T = np.tile(T,(np.append(self.n_other,1)))\n    else: Exception(\"Length of T must be 1 or equal to n\")\n\n    self.h = self.fcns.h(self.T)\n    self.T = self.fcns.T(self.h)\n    self.rho = self.fcns.rho(self.h)\n    self.cp = self.fcns.cp(self.h)\n    self.k = self.fcns.k(self.h)\n    self.D = np.zeros(((2,)+(self.T.shape)))\n    self.F = np.zeros(((2,)+(self.T.shape)))\n    self.S = np.zeros(self.T.shape)\n</code></pre>"},{"location":"source_code/#openterrace.Simulate.Phase.select_massflow","title":"<code>select_massflow(mdot=None)</code>","text":"<p>Initialises mass flow rate field.</p> <p>Parameters:</p> Name Type Description Default <code>mdot</code> <code>float</code> <p>Array of mass flow rate. Column 0 is time and column 1 is mass flow rate</p> <code>None</code> Source code in <code>openterrace/openterrace.py</code> <pre><code>def select_massflow(self, mdot:list[float]=None):\n    \"\"\"Initialises mass flow rate field.\n\n    Args:\n        mdot (float): Array of mass flow rate. Column 0 is time and column 1 is mass flow rate\n    \"\"\"\n\n    self.mdot_array = np.array(mdot)\n</code></pre>"},{"location":"source_code/#openterrace.Simulate.Phase.select_output","title":"<code>select_output(times=None, output_parameters=['T'])</code>","text":"<p>Specify output times.</p> <p>Parameters:</p> Name Type Description Default <code>times</code> <code>float</code> <p>List of times to output data</p> <code>None</code> Source code in <code>openterrace/openterrace.py</code> <pre><code>def select_output(self, times:list[float]=None, output_parameters:list[str]=['T']):\n    \"\"\"Specify output times.\n\n    Args:\n        times (float): List of times to output data\n    \"\"\"\n\n    self.output_parameters = output_parameters\n    class Data(object):\n        pass\n    self.data = Data()\n    self.data.time = np.intersect1d(np.array(times), np.arange(self.outer.t_start, self.outer.t_end+self.outer.dt, self.outer.dt))\n    for parameter in output_parameters:\n        setattr(self.data,parameter, np.full((len(self.data.time), self.n_other, self.n),np.nan))\n        self._flag_save_data = True\n        self._q = 0\n</code></pre>"},{"location":"source_code/#openterrace.Simulate.Phase.select_porosity","title":"<code>select_porosity(phi=1)</code>","text":"<p>Select porosity from 0 to 1, e.g. filling the domain with the phase up to a certain degree.</p> <p>Parameters:</p> Name Type Description Default <code>phi</code> <code>float</code> <p>Porosity value</p> <code>1</code> Source code in <code>openterrace/openterrace.py</code> <pre><code>def select_porosity(self, phi:float=1):\n    \"\"\"Select porosity from 0 to 1, e.g. filling the domain with the phase up to a certain degree.\n\n    Args:\n        phi (float): Porosity value\n    \"\"\"\n\n    self.domain.V = self.domain.V*phi\n    self.phi = phi\n</code></pre>"},{"location":"source_code/#openterrace.Simulate.Phase.select_schemes","title":"<code>select_schemes(diff=None, conv=None)</code>","text":"<p>Imports the specified diffusion and convection schemes.</p> <p>Parameters:</p> Name Type Description Default <code>diff</code> <code>str</code> <p>Differenctial scheme</p> <code>None</code> <code>conv</code> <code>str</code> <p>Convection scheme</p> <code>None</code> Source code in <code>openterrace/openterrace.py</code> <pre><code>def select_schemes(self, diff:str=None, conv:str=None):\n    \"\"\"Imports the specified diffusion and convection schemes.\n\n    Args:\n        diff (str): Differenctial scheme\n        conv (str): Convection scheme\n    \"\"\"\n\n    if self.domain.type == 'lumped':\n        raise Exception(\"'lumped' has been selected as domain type. Please don't specify a discretisation scheme.\")\n\n    if diff is not None:\n        try:\n            self.diff = getattr(getattr(globals()['diffusion_schemes'], diff), diff)\n        except:\n            raise Exception(\"Diffusion scheme \\'\"+diff+\"\\' specified. Valid options for diffusion schemes are:\", diffusion_schemes.__all__)\n\n    if conv is not None:\n        try:\n            self.conv = getattr(getattr(globals()['convection_schemes'], conv), conv)\n        except:\n            raise Exception(\"Convection scheme \\'\"+conv+\"\\' specified. Valid options for convection schemes are:\", convection_schemes.__all__)\n</code></pre>"},{"location":"source_code/#openterrace.Simulate.Phase.select_substance","title":"<code>select_substance(substance=None)</code>","text":"<p>Selects one of the predefined substancers.</p> <p>Parameters:</p> Name Type Description Default <code>substance</code> <code>str</code> <p>Substance name</p> <code>None</code> Source code in <code>openterrace/openterrace.py</code> <pre><code>def select_substance(self, substance:str=None):\n    \"\"\"Selects one of the predefined substancers.\n\n    Args:\n        substance (str): Substance name\n    \"\"\"\n\n    valid_substances = globals()[self.type+'_substances'].__all__\n    if not substance:\n        raise Exception(\"Keyword 'substance' not specified.\")\n    if not substance in valid_substances:\n        raise Exception(substance+\" specified as \"+self.type+\" substance. Valid \"+self.type+\" substances are:\", valid_substances)\n    self.fcns = getattr(globals()[self.type+'_substances'], substance)\n</code></pre>"},{"location":"source_code/#openterrace.Simulate.Phase.select_substance_on_the_fly","title":"<code>select_substance_on_the_fly(cp=None, rho=None, k=None)</code>","text":"<p>Defines and selects a new substance on-the-fly. This is useful for defining a substance for testing purposes with temperature independent properties.</p> <p>Parameters:</p> Name Type Description Default <code>cp</code> <code>float</code> <p>Specific heat capacity in J/(kg K)</p> <code>None</code> <code>rho</code> <code>float</code> <p>Density in kg/m^3</p> <code>None</code> <code>k</code> <code>float</code> <p>Thermal conductivity in W/(m K)</p> <code>None</code> Source code in <code>openterrace/openterrace.py</code> <pre><code>def select_substance_on_the_fly(self, cp:float=None, rho:float=None, k:float=None):\n    \"\"\"Defines and selects a new substance on-the-fly. This is useful for defining a substance for testing purposes with temperature independent properties.\n\n    Args:\n        cp (float): Specific heat capacity in J/(kg K)\n        rho (float): Density in kg/m^3\n        k (float): Thermal conductivity in W/(m K)\n    \"\"\"\n    class dummy:\n        pass\n    self.fcns = dummy()\n    self.fcns.h = lambda T: np.ones_like(T)*T*cp\n    self.fcns.T = lambda h: np.ones_like(h)*h/cp\n    self.fcns.cp = lambda h: np.ones_like(h)*cp\n    self.fcns.k = lambda h: np.ones_like(h)*k\n    self.fcns.rho = lambda h: np.ones_like(h)*rho\n</code></pre>"},{"location":"source_code/#openterrace.Simulate.__init__","title":"<code>__init__(t_start=0, t_end=None, dt=None)</code>","text":"<p>Initialise with various control parameters.</p> <p>Parameters:</p> Name Type Description Default <code>t_start</code> <code>float</code> <p>Start time in s</p> <code>0</code> <code>t_end</code> <code>float</code> <p>End time in s</p> <code>None</code> <code>dt</code> <code>float</code> <p>Time step size in s</p> <code>None</code> Source code in <code>openterrace/openterrace.py</code> <pre><code>def __init__(self, t_start:float=0, t_end:float=None, dt:float=None):\n    \"\"\"Initialise with various control parameters.\n\n    Args:\n        t_start (float): Start time in s\n        t_end (float): End time in s\n        dt (float): Time step size in s\n    \"\"\"\n    self.t_start = t_start\n    self.t_end = t_end\n    self.dt = dt\n    self.coupling = []\n    self.flag_coupling = False\n</code></pre>"},{"location":"source_code/#openterrace.Simulate.create_phase","title":"<code>create_phase(n=None, n_other=1, type=None)</code>","text":"<p>Creates a fluid or bed phase.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of discretisations</p> <code>None</code> <code>n_other</code> <code>int</code> <p>Number of discretisations of interacting phase. If you are defining a bed phase within a tank. Then n_other is the number of discretisations of the fluid phase.</p> <code>1</code> <code>type</code> <code>str</code> <p>Phase type</p> <code>None</code> Source code in <code>openterrace/openterrace.py</code> <pre><code>def create_phase(self, n:int=None, n_other:int=1, type:str=None):\n    \"\"\"Creates a fluid or bed phase.\n\n    Args:\n        n (int): Number of discretisations\n        n_other (int): Number of discretisations of interacting phase. If you are defining a bed phase within a tank. Then n_other is the number of discretisations of the fluid phase.\n        type (str): Phase type\n    \"\"\"\n\n    valid_types = ['fluid','bed']\n    if type not in valid_types:\n        raise Exception(\"Type \\'\"+type+\"\\' specified. Valid options for types are:\", valid_types)\n    return self.Phase(self, n, n_other, type)\n</code></pre>"},{"location":"source_code/#openterrace.Simulate.run_simulation","title":"<code>run_simulation()</code>","text":"<p>If you want to run the simulation, you need to call this function. If data output is specified using the select_output function, the data will live in that specific phase instance. For more details on how to access the data, please refer to the tutorials.</p> Source code in <code>openterrace/openterrace.py</code> <pre><code>def run_simulation(self):\n    \"\"\"If you want to run the simulation, you need to call this function. If data output is specified using the select_output function, the data will live in that specific phase instance. For more details on how to access the data, please refer to the tutorials.\"\"\"\n\n\n    for t in tqdm.tqdm(np.arange(self.t_start, self.t_end+self.dt, self.dt)):\n\n        for phase_instance in self.Phase.instances:\n            phase_instance._save_data(t)\n            phase_instance._solve_equations(t, self.dt)\n            phase_instance._update_properties()\n        if self.flag_coupling:\n            self._coupling()\n</code></pre>"},{"location":"source_code/#openterrace.Simulate.select_coupling","title":"<code>select_coupling(fluid_phase=None, bed_phase=None, h_exp=None, h_value=None)</code>","text":"<p>Selects coupling of a fluid and bed phase</p> <p>Parameters:</p> Name Type Description Default <code>fluid_phase</code> <code>int</code> <p>phase number</p> <code>None</code> <code>bed_phase</code> <code>int</code> <p>phase number</p> <code>None</code> <code>h_exp</code> <code>str</code> <p>Predefined function for convective heat transfer</p> <code>None</code> <code>h_value</code> <code>float</code> <p>Convective heat transfer coefficient in W/(m^2 K)</p> <code>None</code> Source code in <code>openterrace/openterrace.py</code> <pre><code>def select_coupling(self, fluid_phase:int=None, bed_phase:int=None, h_exp:str=None, h_value:float=None):\n    \"\"\"Selects coupling of a fluid and bed phase\n\n    Args:\n        fluid_phase (int): phase number\n        bed_phase (int): phase number\n        h_exp (str): Predefined function for convective heat transfer\n        h_value (float): Convective heat transfer coefficient in W/(m^2 K)\n    \"\"\"\n\n    valid_h_exp = ['constant']\n    if h_exp not in valid_h_exp:\n        raise Exception(\"h_exp \\'\"+h_exp+\"\\' specified. Valid options for h_exp are:\", valid_h_exp)\n\n    self.coupling.append({\"fluid_phase\":fluid_phase, \"bed_phase\":bed_phase, \"h_exp\":h_exp, \"h_value\":h_value})\n    self.flag_coupling = True\n</code></pre>"},{"location":"theory/","title":"Theory","text":""},{"location":"theory/#schematic-overview","title":"Schematic overview","text":"<p>The fluid and bed phase are discretised in N and M nodes respectively. All bed material within the same fluid node is assumed to have the same temperature distribution. </p>"},{"location":"theory/#governing-equations","title":"Governing equations","text":"<p>OpenTerrace solves partial differential equations for both phases.</p> \\[ \\epsilon_f \\rho_f c_{p,f} \\frac{\\partial T}{\\partial t} = - \\rho_f c_{p,f} u \\frac{\\partial T}{\\partial x} + \\frac{\\partial}{\\partial x}\\left( k_f\\frac{\\partial T}{\\partial x}\\right) + S \\] \\[ \\epsilon_b \\rho_b c_{p,b} \\frac{\\partial T}{\\partial t} = \\frac{\\partial}{\\partial x}\\left( k_b\\frac{\\partial T}{\\partial x}\\right) + S \\] <p>The source term S contains effects such as coupling between the phases or heat loss to surroundings.</p>"},{"location":"tutorials/tutorial_1/","title":"Tutorial 1","text":"<pre><code>\"\"\" \nThis example shows how to simulate advection of temperature\nin a cylindrical tank without any bed material. At the bottom (y=0)\nthe temperature is fixed at 80\u2103 (direchlet-type BC), and at the top (y=1)\na neumann-type BC is applied. 20 nodes are used to discretize the domain.\nThe fluid is water, and the mass flow rate is 0.1 kg/s. The simulation\ntime is 600 seconds, and the output is saved every 60 seconds.\n\"\"\"\n\nimport openterrace\nimport matplotlib.pyplot as plt\n\ndef main():\n    ot = openterrace.Simulate(t_end=600, dt=0.01)\n\n    fluid = ot.create_phase(n=20, type='fluid')\n    fluid.select_substance_on_the_fly(rho=1000, cp=4200, k=0.6)\n    fluid.select_domain_shape(domain='cylinder_1d', D=0.3, H=1)\n    fluid.select_schemes(diff='central_difference_1d', conv='upwind_1d')\n    fluid.select_initial_conditions(T=273.15+20)\n    fluid.select_massflow(mdot=0.1)\n    fluid.select_bc(bc_type='fixed_value', \n                    parameter='T', \n                    position=(slice(None, None, None), 0), \n                    value=273.15+80)\n    fluid.select_bc(bc_type='zero_gradient', \n                    parameter='T', \n                    position=(slice(None, None, None), -1), \n                    value=0)\n    fluid.select_output(times=range(0, 15*60+60, 60))\n\n    ot.run_simulation()\n\n    plt.plot(fluid.node_pos,fluid.data.T[:,0,:].T-273.15, label=fluid.data.time)\n    plt.legend(title='Simulation time (s)')\n    plt.show()\n    plt.xlabel(u'Cylinder position (m)')\n    plt.ylabel(u'Temperature (\u2103)')\n    plt.grid()\n    plt.grid(which='major', color='#DDDDDD', linewidth=1)\n    plt.grid(which='minor', color='#EEEEEE', linestyle=':', linewidth=0.8)\n    plt.minorticks_on()\n    plt.savefig('ot_plot_tutorial1.svg')\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tutorials/tutorial_2/","title":"Tutorial 2","text":"<pre><code>\"\"\" \nThis example shows how to simulate advection of temperature\nin a cylindrical tank without any bed material. At the bottom (y=0)\nthe temperature is fixed at 80\u2103 (direchlet-type BC), and at the top (y=1)\na neumann-type BC is applied. 20 nodes are used to discretize the domain.\nThe fluid is water. The simulation time is 600 seconds, and the output\nis saved every 60 seconds.\nAs opposed to the previous example, the mass flow rate is not constant.\nIt is set to 0.1 kg/s for the first 400 seconds. Between 400 and 500\n seconds, the mass flow decreased so that -0.1 kg/s is reached \n after 500 seconds.\n\"\"\"\n\nimport openterrace\nimport matplotlib.pyplot as plt\n\ndef main():\n    ot = openterrace.Simulate(t_end=600, dt=0.01)\n\n    fluid = ot.create_phase(n=500, type='fluid')\n    fluid.select_substance_on_the_fly(rho=1000, cp=4200, k=0.6)\n    fluid.select_domain_shape(domain='cylinder_1d', D=0.3, H=1)\n    fluid.select_schemes(diff='central_difference_1d', conv='upwind_1d')\n    fluid.select_initial_conditions(T=273.15+20)\n    fluid.select_massflow(mdot=[\n                                [0, 0.1],\n                                [400, 0.1],\n                                [500, -0.1]\n                                ])\n\n    fluid.select_bc(bc_type='fixed_value', \n                    parameter='T',\n                    position=(slice(None, None, None), 0),\n                    value=273.15+80)\n    fluid.select_bc(bc_type='zero_gradient', \n                    parameter='T',\n                    position=(slice(None, None, None), -1),\n                    value=0)\n    fluid.select_output(times=range(0, 10*60+45, 45))\n\n    ot.run_simulation()\n\n    plt.plot(fluid.node_pos,fluid.data.T[:,0,:].T-273.15, label=fluid.data.time)\n    plt.legend(title='Simulation time (s)')\n    plt.show()\n    plt.xlabel(u'Cylinder position (m)')\n    plt.ylabel(u'Temperature (\u2103)')\n    plt.grid()\n    plt.grid(which='major', color='#DDDDDD', linewidth=1)\n    plt.grid(which='minor', color='#EEEEEE', linestyle=':', linewidth=0.8)\n    plt.minorticks_on()\n    plt.savefig('ot_plot_tutorial2.svg')\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tutorials/tutorial_3/","title":"Tutorial 3","text":"<pre><code>\"\"\"\nThis example shows how to simulate heat diffusion\nin a sphere made out of swedish diabase stone.\nThe sphere has a radius of 2.5 cm, and the initia \ntemperature is 40\u2103. The sphere is exposed to a \nconvection heat transfer with a heat transfer \ncoefficient of 200 W/m\u00b2K. The simulation time \nis 15 minutes, and the output is saved every 60 seconds.\n\"\"\"\n\nimport openterrace\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef main():\n    D = 0.05\n    T_init = 40+273.15\n    T_inf = 80+273.15\n    h = 200\n\n    ot = openterrace.Simulate(t_end=15*60, dt=0.01)\n\n    bed = ot.create_phase(n=50, type='bed')\n    bed.select_substance('swedish_diabase')\n    bed.select_domain_shape(domain='sphere_1d', R=D/2)\n    bed.select_schemes(diff='central_difference_1d')\n    bed.select_initial_conditions(T=T_init)\n    bed.select_bc(bc_type='zero_gradient', \n                parameter='T', \n                position=(slice(None, None, None), 0))\n    bed.select_bc(bc_type='zero_gradient', \n                parameter='T',\n                position=(slice(None, None, None), -1))\n\n    # Initialise array of thermal resistances\n    R = np.inf*np.ones_like(bed.T)\n\n    # Set thermal resistance for the surface\n    R[0][-1] = 1/(h*4*np.pi*(D/2)**2)\n\n    bed.add_sourceterm_thermal_resistance(R=R, T_inf=T_inf)\n    bed.select_output(times=range(0, 15*60+60, 60))\n\n    ot.run_simulation()\n\n    plt.plot(bed.node_pos,bed.data.T[:,0,:].T-273.15, label=bed.data.time)\n    plt.legend(title='Simulation time (s)')\n    plt.show()\n    plt.xlabel(u'Sphere radial position (m)')\n    plt.ylabel(u'Temperature (\u2103)')\n    plt.grid()\n    plt.grid(which='major', color='#DDDDDD', linewidth=1)\n    plt.grid(which='minor', color='#EEEEEE', linestyle=':', linewidth=0.8)\n    plt.minorticks_on()\n    plt.savefig('ot_plot_tutorial3.svg')\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tutorials/tutorial_4/","title":"Tutorial 4","text":"<pre><code>\"\"\"\nThis example shows how to simulate heat diffusion\nin a hollow sphere made out of ATS58 (PCM material).\nThe sphere has an inner radius of 5 mm and an outer\nradius of 25 mm. The initial temperature is 40\u2103.\nThe sphere is exposed to a convection heat transfer\nwith a heat transfer coefficient of 50 W/m\u00b2K. The\nsimulation time is 100 minutes, and the output is\nsaved every 10 minutes.\n\"\"\"\n\nimport openterrace\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef main():\n    Ri = 0.005\n    Ro = 0.025\n    T_init = 40+273.15\n    T_inf = 80+273.15\n    h = 50\n\n    ot = openterrace.Simulate(t_end=6000, dt=0.05)\n\n    bed = ot.create_phase(n=30, type='bed')\n    bed.select_substance(substance='ATS58')\n    bed.select_domain_shape(domain='hollow_sphere_1d', Rinner=Ri, Router=Ro)\n    bed.select_schemes(diff='central_difference_1d')\n    bed.select_initial_conditions(T=T_init)\n    bed.select_bc(bc_type='zero_gradient', \n                parameter='T',\n                position=(slice(None, None, None), 0))\n    bed.select_bc(bc_type='zero_gradient', \n                parameter='T',\n                position=(slice(None, None, None), -1))\n\n    # Initialise array of thermal resistances\n    R = np.inf*np.ones_like(bed.T)\n\n    # Set thermal resistance for the surface\n    R[0][-1] = 1/(h*4*np.pi*Ro**2)\n\n    bed.add_sourceterm_thermal_resistance(R=R, T_inf=T_inf)\n    bed.select_output(times=range(0, 6000+600, 600))\n\n    ot.run_simulation()\n\n    plt.plot(bed.node_pos,bed.data.T[:,0,:].T-273.15, label=bed.data.time)\n    plt.legend(title='Simulation time (s)')\n    plt.show()\n    plt.xlabel(u'Sphere radial position (m)')\n    plt.ylabel(u'Temperature (\u2103)')\n    plt.grid()\n    plt.grid(which='major', color='#DDDDDD', linewidth=1)\n    plt.grid(which='minor', color='#EEEEEE', linestyle=':', linewidth=0.8)\n    plt.minorticks_on()\n    plt.savefig('ot_plot_tutorial4.svg')\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tutorials/tutorial_5/","title":"Tutorial 5","text":"<pre><code>\"\"\" \nThis example shows how to simulate a cylindrical\nthermal storage tank with air and spherical magnetite\nstones as the bed material. The tank has a diameter of\n30 cm and a height of 1 m. The initial temperature of\nthe air is 25\u2103. The air is heated up to 500\u2103 at the\nbottom. Heat transfer from the fluid phase to the bed\nphase is modelled with a constant heat transfer coefficient\nof 100 W/m\u00b2K. The simulation time is 10 hours, and the\noutput is saved every hour.\n\"\"\"\n\nimport openterrace\nimport matplotlib.pyplot as plt\n\ndef main():\n    t_end = 3600*10\n\n    ot = openterrace.Simulate(t_end=t_end, dt=0.02)\n\n    fluid = ot.create_phase(n=50, type='fluid')\n    fluid.select_substance(substance='air')\n    fluid.select_domain_shape(domain='cylinder_1d', D=0.3, H=1)\n    fluid.select_porosity(phi=0.4)\n    fluid.select_schemes(diff='central_difference_1d', conv='upwind_1d')\n    fluid.select_initial_conditions(T=273.15+25)\n    fluid.select_massflow(mdot=0.01)\n    fluid.select_bc(bc_type='fixed_value',\n                    parameter='T',\n                    position=(slice(None, None, None), 0),\n                    value=273.15+500\n                    )\n    fluid.select_bc(bc_type='zero_gradient',\n                    parameter='T',\n                    position=(slice(None, None, None), -1)\n                    )\n    fluid.select_output(times=range(0, t_end+3600, 3600))\n\n    bed = ot.create_phase(n=20, n_other=50, type='bed')\n    bed.select_substance(substance='magnetite')\n    bed.select_domain_shape(domain='sphere_1d', R=0.05)\n    bed.select_schemes(diff='central_difference_1d')\n    bed.select_initial_conditions(T=273.15+25)\n    bed.select_bc(bc_type='zero_gradient',\n                parameter='T',\n                position=(slice(None, None, None), 0))\n    bed.select_bc(bc_type='zero_gradient',\n                parameter='T',\n                position=(slice(None, None, None), -1))\n    bed.select_output(times=range(0, t_end+3600, 3600))\n\n    ot.select_coupling(fluid_phase=0, bed_phase=1, h_exp='constant', h_value=100)\n    ot.run_simulation()\n\n    plt.plot(fluid.node_pos,fluid.data.T[:,0,:].T-273.15, label=fluid.data.time/3600)\n    plt.legend(title='Simulation time (h)')\n    plt.show()\n    plt.xlabel(u'Cylinder position (m)')\n    plt.ylabel(u'Temperature (\u2103)')\n    plt.grid()\n    plt.grid(which='major', color='#DDDDDD', linewidth=1)\n    plt.grid(which='minor', color='#EEEEEE', linestyle=':', linewidth=0.8)\n    plt.minorticks_on()\n    plt.savefig('ot_plot_tutorial5.svg')\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tutorials/tutorial_6/","title":"Tutorial 6","text":"<pre><code>\"\"\" \nThis example shows how a cylindrical pit storage looses\nenergy to the surroundings over a period of 30 days. The\npit has a diameter of 2 m and a height of 10 m. The initial\ntemperature is 80\u2103. The pit is exposed to a convection heat\ntransfer with a heat transfer coefficient of 10 W/m\u00b2K. The\nsimulation time is 30 days, and the output is saved every\n2 days.\n\"\"\"\n\nimport openterrace\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nD = 2\nR = D/2\nH = 10\nT_inf = 273.15+10\n\ndef main():\n    ot = openterrace.Simulate(t_end=3600*24*14, dt=5)\n\n    fluid = ot.create_phase(n=101, type='fluid')\n    fluid.select_substance_on_the_fly(rho=1000, cp=4200, k=0.6)\n    fluid.select_domain_shape(domain='cylinder_1d', D=D, H=H)\n    fluid.select_schemes(diff='central_difference_1d')\n    fluid.select_initial_conditions(T=273.15+80)\n    fluid.select_bc(bc_type='zero_gradient', \n                    parameter='T', \n                    position=(slice(None, None, None), 0)\n                    )\n    fluid.select_bc(bc_type='zero_gradient', \n                    parameter='T', \n                    position=(slice(None, None, None), -1)\n                    )\n    fluid.select_output(times=range(0, 60*60*24*15, 3600*24*1))\n\n    # Calculate surface area of each node\n    As = fluid.domain.dx*np.pi*D\n\n    # Correct bottom node because its only half the height of the other nodes\n    As[0] = As[0]/2 + np.pi*(D/2)**2\n\n    # Correct top node because its only half the height of the other nodes\n    As[-1] = As[-1]/2 + np.pi*(D/2)**2\n\n    # Overall heat transfer coefficient\n    U = 0.05\n\n    # Thermal resistance\n    R = 1/(U*As)\n\n    fluid.add_sourceterm_thermal_resistance(R=R, T_inf=T_inf)\n\n    ot.run_simulation()\n\n    plt.plot(fluid.node_pos,fluid.data.T[:,0,:].T-273.15, label=fluid.data.time/(3600*24))\n    plt.legend(title='Simulation time (day)')\n    plt.show()\n    plt.xlabel(u'Height (m)')\n    plt.ylabel(u'Temperature (\u2103)')\n    plt.grid()\n    plt.grid(which='major', color='#DDDDDD', linewidth=1)\n    plt.grid(which='minor', color='#EEEEEE', linestyle=':', linewidth=0.8)\n    plt.minorticks_on()\n    plt.savefig('ot_plot_tutorial6.svg')\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"tutorials/tutorial_7/","title":"Tutorial 7","text":"<pre><code>\"\"\"\nThis example sets up a water tank with PCM material\nas the bed material. The tank has a diameter of 10 cm\nand a height of 1 m. The initial temperature of the\nwater is 20\u2103. The water is heated up to 80\u2103 at the\nbottom. Heat transfer from the fluid phase to the bed\nphase is modelled with a constant heat transfer coefficient\nof 200 W/m\u00b2K. The simulation time is 100 minutes, and the\noutput is saved every 5 minutes.\n\"\"\"\n\nimport openterrace\nimport matplotlib.pyplot as plt\n\ndef main():\n    ot = openterrace.Simulate(t_end=100*60, dt=0.05)\n\n    fluid = ot.create_phase(n=100, type='fluid')\n    fluid.select_substance(substance='water')\n    fluid.select_domain_shape(domain='cylinder_1d', D=0.1, H=1)\n    fluid.select_porosity(phi=0.4)\n    fluid.select_schemes(diff='central_difference_1d', conv='upwind_1d')\n    fluid.select_initial_conditions(T=273.15+20)\n    fluid.select_massflow(mdot=0.01)\n    fluid.select_bc(bc_type='fixed_value',\n                    parameter='T',\n                    position=(slice(None, None, None), 0),\n                    value=273.15+80)\n    fluid.select_bc(bc_type='zero_gradient',\n                    parameter='T',\n                    position=(slice(None, None, None), -1))\n    fluid.select_output(times=[0, 30, 60, 90, 120, 150, 180, 210,\n                        240, 270, 300, 600, 900,\n                        1800, 3600, 5400, 6000])\n\n    bed = ot.create_phase(n=20, n_other=100, type='bed')\n    bed.select_substance('ATS58')\n    bed.select_domain_shape(domain='hollow_sphere_1d', Rinner=0.005, Router=0.025)\n    bed.select_schemes(diff='central_difference_1d')\n    bed.select_initial_conditions(T=273.15+20)\n    bed.select_bc(bc_type='zero_gradient',\n                parameter='T',\n                position=(slice(None, None, None), 0))\n    bed.select_bc(bc_type='zero_gradient',\n                parameter='T',\n                position=(slice(None, None, None), -1))\n    bed.select_output(times=range(0,600+300,300))\n\n    ot.select_coupling(fluid_phase=0, bed_phase=1, h_exp='constant', h_value=200)\n    ot.run_simulation()\n\n    plt.plot(fluid.node_pos,fluid.data.T[:,0,:].T-273.15, label=fluid.data.time/60)\n    plt.legend(title='Simulation time (min)')\n    plt.show()\n    plt.xlabel(u'Cylinder position (m)')\n    plt.ylabel(u'Temperature (\u2103)')\n    plt.grid()\n    plt.grid(which='major', color='#DDDDDD', linewidth=1)\n    plt.grid(which='minor', color='#EEEEEE', linestyle=':', linewidth=0.8)\n    plt.minorticks_on()\n    plt.savefig('ot_plot_tutorial7.svg')\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"user-guide/getting-started/","title":"Getting started","text":"<p>Welcome to the OpenTerrace user guide! Using the panel to the left, you may more nerdy details on the equations being solved along with the numerous substances, domain types and numerical schemes that come with OpenTerrace. Also, verification and validation studies are presented.</p>"},{"location":"user-guide/bed_substances/ATS50/","title":"ATS50","text":"<p>Data for ATS50 phase change material.</p> <p>Reference: https://www.axiotherm.de/en/download/project/productdatasheet/file/17/</p> <p>T_s = 49+273.15 (solidification temperature) T_l = 50+273.15 (liquid temperature) k_s = 1 (solid thermal conductivity) k_l = 0.6 (liquid thermal conductivity) h_f = 228000 (latent heat of fusion) cp = 3000 (specific heat capacity at constant pressure) rho_l = 1300 (liquid density) rho_s = 1300 (solid density) h_s = T_scp (mass specific enthalpy before phase change) h_l = T_scp+h_f (mass specific enthalpy at after phase change)</p>"},{"location":"user-guide/bed_substances/ATS50/#bed_substances.ATS50.T","title":"<code>T(h, p=None)</code>","text":"<p>Temperature as function of mass specific enthalpy at 1 atm (fit assumes piecewice constant cp with phase change).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Temperature in kelvin</p> Source code in <code>openterrace/bed_substances/ATS50.py</code> <pre><code>def T(h:float, p:float=None) -&gt; float:\n    \"\"\"Temperature as function of mass specific enthalpy at 1 atm (fit assumes piecewice constant cp with phase change).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Temperature in kelvin\n    \"\"\"\n    return np.piecewise(h, [h &lt;= _h_s, (h &gt; _h_s) &amp; (h &lt;= _h_l), h &gt; _h_l], [lambda h: 1/_cp*h, lambda h: _T_s + (_T_l-_T_s)*(h-_h_s)/(_h_l-_h_s), lambda h: _T_l + 1/_cp*(h-_h_l)])\n</code></pre>"},{"location":"user-guide/bed_substances/ATS50/#bed_substances.ATS50.cp","title":"<code>cp(h, p=None)</code>","text":"<p>Specific heat capacity as function of mass specific enthalpy at 1 atm (fit assumes piecewice constant cp with phase change).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Specific heat capacity in J/(kg K)</p> Source code in <code>openterrace/bed_substances/ATS50.py</code> <pre><code>def cp(h:float, p:float=None) -&gt; float:\n    \"\"\"Specific heat capacity as function of mass specific enthalpy at 1 atm (fit assumes piecewice constant cp with phase change).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        float: Specific heat capacity in J/(kg K)\n    \"\"\"\n    return _cp*h**0\n</code></pre>"},{"location":"user-guide/bed_substances/ATS50/#bed_substances.ATS50.h","title":"<code>h(T)</code>","text":"<p>Mass specific enthalpy as function of temperature at 1 atm (fit assumes piecewice constant cp with phase change).</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>float</code> <p>Temperature in K</p> required <p>Returns:</p> Type Description <code>float</code> <p>Specific enthalpy in J/kg</p> Source code in <code>openterrace/bed_substances/ATS50.py</code> <pre><code>def h(T:float) -&gt; float:\n    \"\"\"Mass specific enthalpy as function of temperature at 1 atm (fit assumes piecewice constant cp with phase change).\n\n    Args:\n        T (float): Temperature in K\n\n    Returns:\n        Specific enthalpy in J/kg\n    \"\"\"\n    return np.piecewise(T, [T &lt;= _T_s, (T &gt; _T_s) &amp; (T &lt;= _T_l), T &gt; _T_l], [lambda T: _cp*T, lambda T: _h_s + (T-_T_s)/(_T_l-_T_s)*_h_f, lambda T: _h_l + _cp*(T-_T_l)])\n</code></pre>"},{"location":"user-guide/bed_substances/ATS50/#bed_substances.ATS50.k","title":"<code>k(h, p=None)</code>","text":"<p>Thermal conductivity as function of mass specific enthalpy at 1 atm (fit assumes piecewice constant k).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Thermal conductivity in W/(m K)</p> Source code in <code>openterrace/bed_substances/ATS50.py</code> <pre><code>def k(h:float, p:float=None) -&gt; float:\n    \"\"\"Thermal conductivity as function of mass specific enthalpy at 1 atm (fit assumes piecewice constant k).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        float: Thermal conductivity in W/(m K)\n    \"\"\"\n    return np.piecewise(h, [h &lt;= _h_s, (h &gt; _h_s) &amp; (h &lt;= _h_l), h &gt; _h_l], [_k_s, lambda h: _k_s + (_k_l-_k_s)/(_h_l-_h_s)*(h-_h_s), _k_l])\n</code></pre>"},{"location":"user-guide/bed_substances/ATS50/#bed_substances.ATS50.rho","title":"<code>rho(h, p=None)</code>","text":"<p>Density as function of mass specific entahlpy at 1 atm (fit assumes constant density).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Density in kg/m^3</p> Source code in <code>openterrace/bed_substances/ATS50.py</code> <pre><code>def rho(h:float, p:float=None) -&gt; float:\n    \"\"\"Density as function of mass specific entahlpy at 1 atm (fit assumes constant density).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        float: Density in kg/m^3\n    \"\"\"\n    return _rho_l*h**0\n</code></pre>"},{"location":"user-guide/bed_substances/ATS58/","title":"ATS58","text":"<p>Data for ATS58 phase change material.</p> <p>Reference: https://www.axiotherm.de/en/download/project/productdatasheet/file/19/</p> <p>T_s = 56+273.15 (solidification temperature) T_l = 58+273.15 (liquid temperature) k_s = 1 (solid thermal conductivity) k_l = 0.6 (liquid thermal conductivity) h_f = 240000 (latent heat of fusion) cp = 3000 (specific heat capacity at constant pressure) rho_l = 1280 (liquid density) rho_s = 1280 (solid density) h_s = T_scp (mass specific enthalpy before phase change) h_l = T_scp+h_f (mass specific enthalpy at after phase change)</p>"},{"location":"user-guide/bed_substances/ATS58/#bed_substances.ATS58.T","title":"<code>T(h, p=None)</code>","text":"<p>Temperature as function of mass specific enthalpy at 1 atm (fit assumes piecewice constant cp with phase change).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Temperature in kelvin</p> Source code in <code>openterrace/bed_substances/ATS58.py</code> <pre><code>def T(h:float, p:float=None) -&gt; float:\n    \"\"\"Temperature as function of mass specific enthalpy at 1 atm (fit assumes piecewice constant cp with phase change).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Temperature in kelvin\n    \"\"\"\n    return np.piecewise(h, [h &lt;= _h_s, (h &gt; _h_s) &amp; (h &lt;= _h_l), h &gt; _h_l], [lambda h: 1/_cp*h, lambda h: _T_s + (_T_l-_T_s)*(h-_h_s)/(_h_l-_h_s), lambda h: _T_l + 1/_cp*(h-_h_l)])\n</code></pre>"},{"location":"user-guide/bed_substances/ATS58/#bed_substances.ATS58.cp","title":"<code>cp(h, p=None)</code>","text":"<p>Specific heat capacity as function of mass specific enthalpy at 1 atm (fit assumes piecewice constant cp with phase change).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Specific heat capacity in J/(kg K)</p> Source code in <code>openterrace/bed_substances/ATS58.py</code> <pre><code>def cp(h:float, p:float=None) -&gt; float:\n    \"\"\"Specific heat capacity as function of mass specific enthalpy at 1 atm (fit assumes piecewice constant cp with phase change).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        float: Specific heat capacity in J/(kg K)\n    \"\"\"\n    return _cp*h**0\n</code></pre>"},{"location":"user-guide/bed_substances/ATS58/#bed_substances.ATS58.h","title":"<code>h(T)</code>","text":"<p>Mass specific enthalpy as function of temperature at 1 atm (fit assumes piecewice constant cp with phase change).</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>float</code> <p>Temperature in K</p> required <p>Returns:</p> Type Description <code>float</code> <p>Specific enthalpy in J/kg</p> Source code in <code>openterrace/bed_substances/ATS58.py</code> <pre><code>def h(T:float) -&gt; float:\n    \"\"\"Mass specific enthalpy as function of temperature at 1 atm (fit assumes piecewice constant cp with phase change).\n\n    Args:\n        T (float): Temperature in K\n\n    Returns:\n        Specific enthalpy in J/kg\n    \"\"\"\n    return np.piecewise(T, [T &lt;= _T_s, (T &gt; _T_s) &amp; (T &lt;= _T_l), T &gt; _T_l], [lambda T: _cp*T, lambda T: _h_s + (T-_T_s)/(_T_l-_T_s)*_h_f, lambda T: _h_l + _cp*(T-_T_l)])\n</code></pre>"},{"location":"user-guide/bed_substances/ATS58/#bed_substances.ATS58.k","title":"<code>k(h, p=None)</code>","text":"<p>Thermal conductivity as function of mass specific enthalpy at 1 atm (fit assumes piecewice constant k).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Thermal conductivity in W/(m K)</p> Source code in <code>openterrace/bed_substances/ATS58.py</code> <pre><code>def k(h:float, p:float=None) -&gt; float:\n    \"\"\"Thermal conductivity as function of mass specific enthalpy at 1 atm (fit assumes piecewice constant k).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        float: Thermal conductivity in W/(m K)\n    \"\"\"\n    return np.piecewise(h, [h &lt;= _h_s, (h &gt; _h_s) &amp; (h &lt;= _h_l), h &gt; _h_l], [_k_s, lambda h: _k_s + (_k_l-_k_s)/(_h_l-_h_s)*(h-_h_s), _k_l])\n</code></pre>"},{"location":"user-guide/bed_substances/ATS58/#bed_substances.ATS58.rho","title":"<code>rho(h, p=None)</code>","text":"<p>Density as function of mass specific entahlpy at 1 atm (fit assumes constant density).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Density in kg/m^3</p> Source code in <code>openterrace/bed_substances/ATS58.py</code> <pre><code>def rho(h:float, p:float=None) -&gt; float:\n    \"\"\"Density as function of mass specific entahlpy at 1 atm (fit assumes constant density).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        float: Density in kg/m^3\n    \"\"\"\n    return _rho_l*h**0\n</code></pre>"},{"location":"user-guide/bed_substances/magnetite/","title":"Magnetite","text":"<p>Data for Magnetite.</p> <p>cp = 1130 (specific heat capacity at constant pressure) rho = 5150 (density) k = 1.9 (thermal conductivity)</p>"},{"location":"user-guide/bed_substances/magnetite/#bed_substances.magnetite.T","title":"<code>T(h, p=None)</code>","text":"<p>Temperature as function of mass specific enthalpy at 1 atm (fit assumes constant cp).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Temperature in kelvin</p> Source code in <code>openterrace/bed_substances/magnetite.py</code> <pre><code>def T(h:float, p:float=None) -&gt; float:\n    \"\"\"Temperature as function of mass specific enthalpy at 1 atm (fit assumes constant cp).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Temperature in kelvin\n    \"\"\"\n    return 1/1130*h\n</code></pre>"},{"location":"user-guide/bed_substances/magnetite/#bed_substances.magnetite.cp","title":"<code>cp(h, p=None)</code>","text":"<p>Specific heat capacity as function of mass specific enthalpy at 1 atm (fit assumes constant specific heat capacity).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Specific heat capacity in J/(kg K)</p> Source code in <code>openterrace/bed_substances/magnetite.py</code> <pre><code>def cp(h:float, p:float=None) -&gt; float:\n    \"\"\"Specific heat capacity as function of mass specific enthalpy at 1 atm (fit assumes constant specific heat capacity).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        float: Specific heat capacity in J/(kg K)\n    \"\"\"\n    return 1130*h**0\n</code></pre>"},{"location":"user-guide/bed_substances/magnetite/#bed_substances.magnetite.h","title":"<code>h(T)</code>","text":"<p>Mass specific enthalpy as function of temperature at 1 atm (fit assumes constant cp).</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>float</code> <p>Temperature in K</p> required <p>Returns:</p> Type Description <code>float</code> <p>Specific enthalpy in J/kg</p> Source code in <code>openterrace/bed_substances/magnetite.py</code> <pre><code>def h(T:float) -&gt; float:\n    \"\"\"Mass specific enthalpy as function of temperature at 1 atm (fit assumes constant cp).\n\n    Args:\n        T (float): Temperature in K\n\n    Returns:\n        Specific enthalpy in J/kg\n    \"\"\"\n    return 1130*T\n</code></pre>"},{"location":"user-guide/bed_substances/magnetite/#bed_substances.magnetite.k","title":"<code>k(h, p=None)</code>","text":"<p>Thermal conductivity as function of mass specific enthalpy at 1 atm (fit assumes constant thermal conductivity).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Thermal conductivity in W/(m K)</p> Source code in <code>openterrace/bed_substances/magnetite.py</code> <pre><code>def k(h:float, p:float=None) -&gt; float:\n    \"\"\"Thermal conductivity as function of mass specific enthalpy at 1 atm (fit assumes constant thermal conductivity).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        float: Thermal conductivity in W/(m K)\n    \"\"\"\n    return 1.9*h**0\n</code></pre>"},{"location":"user-guide/bed_substances/magnetite/#bed_substances.magnetite.rho","title":"<code>rho(h, p=None)</code>","text":"<p>Density as function of mass specific entahlpy at 1 atm (fit assumes constant density).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Density in kg/m^3</p> Source code in <code>openterrace/bed_substances/magnetite.py</code> <pre><code>def rho(h:float, p:float=None) -&gt; float:\n    \"\"\"Density as function of mass specific entahlpy at 1 atm (fit assumes constant density).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Density in kg/m^3\n    \"\"\"\n    return 5150*h**0\n</code></pre>"},{"location":"user-guide/bed_substances/swedish_diabase/","title":"Swedish diabase","text":"<p>Data for Swedish Diabase.</p> <p>cp = 1272 (specific heat capacity at constant pressure) rho = 3007 (density) k = 1.75 (thermal conductivity)</p>"},{"location":"user-guide/bed_substances/swedish_diabase/#bed_substances.swedish_diabase.T","title":"<code>T(h, p=None)</code>","text":"<p>Temperature as function of mass specific enthalpy at 1 atm (fit assumes constant cp).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Temperature in kelvin</p> Source code in <code>openterrace/bed_substances/swedish_diabase.py</code> <pre><code>def T(h:float, p:float=None) -&gt; float:\n    \"\"\"Temperature as function of mass specific enthalpy at 1 atm (fit assumes constant cp).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Temperature in kelvin\n    \"\"\"\n    return 1/1272*h\n</code></pre>"},{"location":"user-guide/bed_substances/swedish_diabase/#bed_substances.swedish_diabase.cp","title":"<code>cp(h, p=None)</code>","text":"<p>Specific heat capacity as function of mass specific enthalpy at 1 atm (fit assumes constant specific heat capacity).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Specific heat capacity in J/(kg K)</p> Source code in <code>openterrace/bed_substances/swedish_diabase.py</code> <pre><code>def cp(h:float, p:float=None) -&gt; float:\n    \"\"\"Specific heat capacity as function of mass specific enthalpy at 1 atm (fit assumes constant specific heat capacity).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        float: Specific heat capacity in J/(kg K)\n    \"\"\"\n    return 1272*h**0\n</code></pre>"},{"location":"user-guide/bed_substances/swedish_diabase/#bed_substances.swedish_diabase.h","title":"<code>h(T)</code>","text":"<p>Mass specific enthalpy as function of temperature at 1 atm (fit assumes constant cp).</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>float</code> <p>Temperature in K</p> required <p>Returns:</p> Type Description <code>float</code> <p>Specific enthalpy in J/kg</p> Source code in <code>openterrace/bed_substances/swedish_diabase.py</code> <pre><code>def h(T:float) -&gt; float:\n    \"\"\"Mass specific enthalpy as function of temperature at 1 atm (fit assumes constant cp).\n\n    Args:\n        T (float): Temperature in K\n\n    Returns:\n        Specific enthalpy in J/kg\n    \"\"\"\n    return 1272*T\n</code></pre>"},{"location":"user-guide/bed_substances/swedish_diabase/#bed_substances.swedish_diabase.k","title":"<code>k(h, p=None)</code>","text":"<p>Thermal conductivity as function of mass specific enthalpy at 1 atm (fit assumes constant thermal conductivity).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Thermal conductivity in W/(m K)</p> Source code in <code>openterrace/bed_substances/swedish_diabase.py</code> <pre><code>def k(h:float, p:float=None) -&gt; float:\n    \"\"\"Thermal conductivity as function of mass specific enthalpy at 1 atm (fit assumes constant thermal conductivity).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        float: Thermal conductivity in W/(m K)\n    \"\"\"\n    return 1.75*h**0\n</code></pre>"},{"location":"user-guide/bed_substances/swedish_diabase/#bed_substances.swedish_diabase.rho","title":"<code>rho(h, p=None)</code>","text":"<p>Density as function of mass specific entahlpy at 1 atm (fit assumes constant density).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Density in kg/m^3</p> Source code in <code>openterrace/bed_substances/swedish_diabase.py</code> <pre><code>def rho(h:float, p:float=None) -&gt; float:\n    \"\"\"Density as function of mass specific entahlpy at 1 atm (fit assumes constant density).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Density in kg/m^3\n    \"\"\"\n    return 3007*h**0\n</code></pre>"},{"location":"user-guide/convection_schemes/upwind_1d/","title":"Upwind 1d","text":""},{"location":"user-guide/convection_schemes/upwind_1d/#convection_schemes.upwind_1d.upwind_1d","title":"<code>upwind_1d(x, F)</code>","text":"<p>First-order accurate, unconditionally stable, non-conservative upwind advection scheme.</p> Source code in <code>openterrace/convection_schemes/upwind_1d.py</code> <pre><code>@nb.njit\ndef upwind_1d(x, F):\n    \"\"\"First-order accurate, unconditionally stable, non-conservative upwind advection scheme.\n    \"\"\"\n    _out = np.zeros_like(x)\n    for j in range(0, x.shape[0]):\n        for i in range(1, x.shape[1]-1):\n            _out[j,i] = x[j,i+1]*(-np.minimum(F[0,j,i],0))\\\n                + x[j,i-1]*(np.maximum(F[1,j,i],0))\\\n                + x[j,i]*(np.minimum(F[0,j,i],0)-np.maximum(F[1,j,i],0))\n    return _out\n</code></pre>"},{"location":"user-guide/diffusion_schemes/central_difference_1d/","title":"Central difference 1d","text":""},{"location":"user-guide/diffusion_schemes/central_difference_1d/#diffusion_schemes.central_difference_1d.central_difference_1d","title":"<code>central_difference_1d(x, D)</code>","text":"<p>Second-order accurate central diffence scheme.</p> Source code in <code>openterrace/diffusion_schemes/central_difference_1d.py</code> <pre><code>@nb.njit\ndef central_difference_1d(x, D):\n    \"\"\"Second-order accurate central diffence scheme.\n    \"\"\"\n    _out = np.zeros_like(x)\n    for j in range(0, x.shape[0]):\n        for i in range(1, x.shape[1]-1):\n            _out[j,i] = x[j,i-1]*D[0,j,i] + x[j,i+1]*D[1,j,i]\\\n                - x[j,i]*(D[0,j,i]+D[1,j,i])             \n    return _out\n</code></pre>"},{"location":"user-guide/domains/block_1d/","title":"Block 1d","text":""},{"location":"user-guide/domains/block_1d/#domains.block_1d.A","title":"<code>A(vars)</code>","text":"<p>Area of faces between nodes.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/block_1d.py</code> <pre><code>def A(vars):\n    \"\"\"Area of faces between nodes.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    A = vars['A']\n    return (np.repeat(A,n), np.repeat(A,n))\n</code></pre>"},{"location":"user-guide/domains/block_1d/#domains.block_1d.V","title":"<code>V(vars)</code>","text":"<p>Volume of node element.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/block_1d.py</code> <pre><code>def V(vars):\n    \"\"\"Volume of node element.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    A = vars['A']\n    L = vars['L']\n    dx = L/(n-1)\n    face_pos_vec = np.concatenate(([0], np.linspace(dx/2,L-dx/2,n-1), [L]))\n    return np.diff(A*face_pos_vec)\n</code></pre>"},{"location":"user-guide/domains/block_1d/#domains.block_1d.V0","title":"<code>V0(vars)</code>","text":"<p>Volume of shape.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/block_1d.py</code> <pre><code>def V0(vars):\n    \"\"\"Volume of shape.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    A = vars['A']\n    L = vars['L']\n    return A*L\n</code></pre>"},{"location":"user-guide/domains/block_1d/#domains.block_1d.dx","title":"<code>dx(vars)</code>","text":"<p>Node spacing function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/block_1d.py</code> <pre><code>def dx(vars):\n    \"\"\"Node spacing function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    L = vars['L']\n    dx = L/(n-1)\n    return np.repeat(dx, n)\n</code></pre>"},{"location":"user-guide/domains/block_1d/#domains.block_1d.node_pos","title":"<code>node_pos(vars)</code>","text":"<p>Node position function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/block_1d.py</code> <pre><code>def node_pos(vars):\n    \"\"\"Node position function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    L = vars['L']\n    return np.array(np.linspace(0,L,n))\n</code></pre>"},{"location":"user-guide/domains/block_1d/#domains.block_1d.shape","title":"<code>shape(vars)</code>","text":"<p>Shape function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/block_1d.py</code> <pre><code>def shape(vars):\n    \"\"\"Shape function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    return np.array([n])\n</code></pre>"},{"location":"user-guide/domains/block_1d/#domains.block_1d.validate_input","title":"<code>validate_input(vars, domain_shape)</code>","text":"<p>Validates input arguments.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required <code>domain_shape</code> <code>str</code> <p>Name of domain type</p> required Source code in <code>openterrace/domains/block_1d.py</code> <pre><code>def validate_input(vars, domain_shape):\n    \"\"\"Validates input arguments.\n\n    Args:\n        vars (list): List of arguments\n        domain_shape (str): Name of domain type\n    \"\"\"\n\n    required = ['n','A','L']\n    for var in required:\n        if not var in vars:\n            raise Exception(\"Keyword \\'\"+var+\"\\' not specified for domain of type \\'\"+domain_shape+\"\\'\")\n</code></pre>"},{"location":"user-guide/domains/cylinder_1d/","title":"Cylinder 1d","text":""},{"location":"user-guide/domains/cylinder_1d/#domains.cylinder_1d.A","title":"<code>A(vars)</code>","text":"<p>Area of faces between nodes.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/cylinder_1d.py</code> <pre><code>def A(vars):\n    \"\"\"Area of faces between nodes.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    D = vars['D']\n    H = vars['H']\n    return (np.repeat(np.pi*(D/2)**2, n), np.repeat(np.pi*(D/2)**2, n))\n</code></pre>"},{"location":"user-guide/domains/cylinder_1d/#domains.cylinder_1d.V","title":"<code>V(vars)</code>","text":"<p>Volume of node element.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/cylinder_1d.py</code> <pre><code>def V(vars):\n    \"\"\"Volume of node element.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    D = vars['D']\n    H = vars['H']\n    dx = H/(n-1)\n    face_pos_vec = np.concatenate(([0],np.linspace(dx/2,H-dx/2,n-1),[H]))\n    return np.diff(np.pi*(D/2)**2*face_pos_vec)\n</code></pre>"},{"location":"user-guide/domains/cylinder_1d/#domains.cylinder_1d.V0","title":"<code>V0(vars)</code>","text":"<p>Volume of shape.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/cylinder_1d.py</code> <pre><code>def V0(vars):\n    \"\"\"Volume of shape.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    D = vars['D']\n    H = vars['H']\n    return np.pi*(D/2)**2*H\n</code></pre>"},{"location":"user-guide/domains/cylinder_1d/#domains.cylinder_1d.dx","title":"<code>dx(vars)</code>","text":"<p>Node spacing function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/cylinder_1d.py</code> <pre><code>def dx(vars):\n    \"\"\"Node spacing function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    H = vars['H']\n    dx = H/(n-1)\n    return np.repeat(dx, n)\n</code></pre>"},{"location":"user-guide/domains/cylinder_1d/#domains.cylinder_1d.node_pos","title":"<code>node_pos(vars)</code>","text":"<p>Node position function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/cylinder_1d.py</code> <pre><code>def node_pos(vars):\n    \"\"\"Node position function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    H = vars['H']\n    return np.array(np.linspace(0,H,n))\n</code></pre>"},{"location":"user-guide/domains/cylinder_1d/#domains.cylinder_1d.shape","title":"<code>shape(vars)</code>","text":"<p>Shape function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/cylinder_1d.py</code> <pre><code>def shape(vars):\n    \"\"\"Shape function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    return np.array([n])\n</code></pre>"},{"location":"user-guide/domains/cylinder_1d/#domains.cylinder_1d.validate_input","title":"<code>validate_input(vars, domain_shape)</code>","text":"<p>Validates input arguments.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required <code>domain_shape</code> <code>str</code> <p>Name of domain type</p> required Source code in <code>openterrace/domains/cylinder_1d.py</code> <pre><code>def validate_input(vars, domain_shape):\n    \"\"\"Validates input arguments.\n\n    Args:\n        vars (list): List of arguments\n        domain_shape (str): Name of domain type\n    \"\"\"\n\n    required = ['n','D','H']\n    for var in required:\n        if not var in vars:\n            raise Exception(\"Keyword \\'\"+var+\"\\' not specified for domain of type \\'\"+domain_shape+\"\\'\")\n</code></pre>"},{"location":"user-guide/domains/hollow_sphere_1d/","title":"Hollow sphere 1d","text":""},{"location":"user-guide/domains/hollow_sphere_1d/#domains.hollow_sphere_1d.A","title":"<code>A(vars)</code>","text":"<p>Area of faces between nodes.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/hollow_sphere_1d.py</code> <pre><code>def A(vars):\n    \"\"\"Area of faces between nodes.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    Rinner = vars['Rinner']\n    Router = vars['Router']\n    dx = (Router-Rinner)/(n-1)\n    face_pos_vec = np.concatenate(([Rinner],np.linspace(Rinner+dx/2,Router-dx/2,n-1),[Router]))\n    return np.array([(4*np.pi*face_pos_vec**2)[:-1], (4*np.pi*face_pos_vec**2)[1:]])\n</code></pre>"},{"location":"user-guide/domains/hollow_sphere_1d/#domains.hollow_sphere_1d.V","title":"<code>V(vars)</code>","text":"<p>Volume of node element.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/hollow_sphere_1d.py</code> <pre><code>def V(vars):\n    \"\"\"Volume of node element.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    Rinner = vars['Rinner']\n    Router = vars['Router']\n    dx = (Router-Rinner)/(n-1)\n    face_pos_vec = np.concatenate(([Rinner],np.linspace(Rinner+dx/2,Router-dx/2,n-1),[Router]))\n    return np.diff(4/3*np.pi*face_pos_vec**3)\n</code></pre>"},{"location":"user-guide/domains/hollow_sphere_1d/#domains.hollow_sphere_1d.V0","title":"<code>V0(vars)</code>","text":"<p>Volume of shape.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/hollow_sphere_1d.py</code> <pre><code>def V0(vars):\n    \"\"\"Volume of shape.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    Router = vars['Router']\n    return 4/3*np.pi*Router**3\n</code></pre>"},{"location":"user-guide/domains/hollow_sphere_1d/#domains.hollow_sphere_1d.dx","title":"<code>dx(vars)</code>","text":"<p>Node spacing function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/hollow_sphere_1d.py</code> <pre><code>def dx(vars):\n    \"\"\"Node spacing function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    Rinner = vars['Rinner']\n    Router = vars['Router']\n    dx = (Router-Rinner)/(n-1)\n    return np.repeat(dx, n)\n</code></pre>"},{"location":"user-guide/domains/hollow_sphere_1d/#domains.hollow_sphere_1d.node_pos","title":"<code>node_pos(vars)</code>","text":"<p>Node position function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/hollow_sphere_1d.py</code> <pre><code>def node_pos(vars):\n    \"\"\"Node position function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    Rinner = vars['Rinner']\n    Router = vars['Router']\n    return np.array(np.linspace(Rinner,Router,n))\n</code></pre>"},{"location":"user-guide/domains/hollow_sphere_1d/#domains.hollow_sphere_1d.shape","title":"<code>shape(vars)</code>","text":"<p>Shape function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/hollow_sphere_1d.py</code> <pre><code>def shape(vars):\n    \"\"\"Shape function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    return np.array([n])\n</code></pre>"},{"location":"user-guide/domains/hollow_sphere_1d/#domains.hollow_sphere_1d.validate_input","title":"<code>validate_input(vars, domain_shape)</code>","text":"<p>Validates input arguments.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required <code>domain_shape</code> <code>str</code> <p>Name of domain type</p> required Source code in <code>openterrace/domains/hollow_sphere_1d.py</code> <pre><code>def validate_input(vars, domain_shape):\n    \"\"\"Validates input arguments.\n\n    Args:\n        vars (list): List of arguments\n        domain_shape (str): Name of domain type\n    \"\"\"\n\n    required = ['n','Rinner','Router']\n    for var in required:\n        if not var in vars:\n            raise Exception(\"Keyword \\'\"+var+\"\\' not specified for domain of type \\'\"+domain_shape+\"\\'\")\n</code></pre>"},{"location":"user-guide/domains/lumped/","title":"Lumped","text":""},{"location":"user-guide/domains/lumped/#domains.lumped.A","title":"<code>A(vars)</code>","text":"<p>Area of faces between nodes.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/lumped.py</code> <pre><code>def A(vars):\n    \"\"\"Area of faces between nodes.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    A = vars['A']\n    return np.array([[0,0],[0,A]])\n</code></pre>"},{"location":"user-guide/domains/lumped/#domains.lumped.V","title":"<code>V(vars)</code>","text":"<p>Volume of node element.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/lumped.py</code> <pre><code>def V(vars):\n    \"\"\"Volume of node element.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    V = vars['V']\n    return np.repeat(V,1)\n</code></pre>"},{"location":"user-guide/domains/lumped/#domains.lumped.V0","title":"<code>V0(vars)</code>","text":"<p>Volume of shape.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/lumped.py</code> <pre><code>def V0(vars):\n    \"\"\"Volume of shape.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    V = vars['V']    \n    return V\n</code></pre>"},{"location":"user-guide/domains/lumped/#domains.lumped.dx","title":"<code>dx(vars)</code>","text":"<p>Node spacing function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/lumped.py</code> <pre><code>def dx(vars):\n    \"\"\"Node spacing function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    return np.repeat(0, 1)\n</code></pre>"},{"location":"user-guide/domains/lumped/#domains.lumped.node_pos","title":"<code>node_pos(vars)</code>","text":"<p>Node position function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/lumped.py</code> <pre><code>def node_pos(vars):\n    \"\"\"Node position function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    return np.array([0, 1])\n</code></pre>"},{"location":"user-guide/domains/lumped/#domains.lumped.shape","title":"<code>shape(vars)</code>","text":"<p>Shape function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/lumped.py</code> <pre><code>def shape(vars):\n    \"\"\"Shape function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n    n = 1\n    return np.array([n])\n</code></pre>"},{"location":"user-guide/domains/lumped/#domains.lumped.validate_input","title":"<code>validate_input(vars, domain_shape)</code>","text":"<p>Validates input arguments.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required <code>domain_shape</code> <code>str</code> <p>Name of domain type</p> required Source code in <code>openterrace/domains/lumped.py</code> <pre><code>def validate_input(vars, domain_shape):\n    \"\"\"Validates input arguments.\n\n    Args:\n        vars (list): List of arguments\n        domain_shape (str): Name of domain type\n    \"\"\"\n\n    required = ['V','A']\n    for var in required:\n        if not var in vars:\n            raise Exception(\"Keyword \\'\"+var+\"\\' not specified for domain of type \\'\"+domain_shape+\"\\'\")\n</code></pre>"},{"location":"user-guide/domains/sphere_1d/","title":"Sphere 1d","text":""},{"location":"user-guide/domains/sphere_1d/#domains.sphere_1d.A","title":"<code>A(vars)</code>","text":"<p>Area of faces between nodes.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/sphere_1d.py</code> <pre><code>def A(vars):\n    \"\"\"Area of faces between nodes.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    R = vars['R']\n    dx = R/(n-1)\n    face_pos_vec = np.concatenate(([0],np.linspace(dx/2,R-dx/2,n-1),[R]))\n    return np.array([(4*np.pi*face_pos_vec**2)[:-1], (4*np.pi*face_pos_vec**2)[1:]])\n</code></pre>"},{"location":"user-guide/domains/sphere_1d/#domains.sphere_1d.V","title":"<code>V(vars)</code>","text":"<p>Volume of node element.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/sphere_1d.py</code> <pre><code>def V(vars):\n    \"\"\"Volume of node element.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    R = vars['R']\n    dx = R/(n-1)\n    face_pos_vec = np.concatenate(([0],np.linspace(dx/2,R-dx/2,n-1),[R]))\n    return np.diff(4/3*np.pi*face_pos_vec**3)\n</code></pre>"},{"location":"user-guide/domains/sphere_1d/#domains.sphere_1d.V0","title":"<code>V0(vars)</code>","text":"<p>Volume of shape.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/sphere_1d.py</code> <pre><code>def V0(vars):\n    \"\"\"Volume of shape.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    R = vars['R']\n    return 4/3*np.pi*R**3\n</code></pre>"},{"location":"user-guide/domains/sphere_1d/#domains.sphere_1d.dx","title":"<code>dx(vars)</code>","text":"<p>Node spacing function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/sphere_1d.py</code> <pre><code>def dx(vars):\n    \"\"\"Node spacing function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    R = vars['R']\n    dx = R/(n-1)\n    return np.repeat(dx, n)\n</code></pre>"},{"location":"user-guide/domains/sphere_1d/#domains.sphere_1d.node_pos","title":"<code>node_pos(vars)</code>","text":"<p>Node position function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/sphere_1d.py</code> <pre><code>def node_pos(vars):\n    \"\"\"Node position function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    R = vars['R']\n    return np.array(np.linspace(0,R,n))\n</code></pre>"},{"location":"user-guide/domains/sphere_1d/#domains.sphere_1d.shape","title":"<code>shape(vars)</code>","text":"<p>Shape function.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required Source code in <code>openterrace/domains/sphere_1d.py</code> <pre><code>def shape(vars):\n    \"\"\"Shape function.\n\n    Args:\n        vars (list): List of arguments\n    \"\"\"\n\n    n = vars['n']\n    return np.array([n])\n</code></pre>"},{"location":"user-guide/domains/sphere_1d/#domains.sphere_1d.validate_input","title":"<code>validate_input(vars, domain_shape)</code>","text":"<p>Validates input arguments.</p> <p>Parameters:</p> Name Type Description Default <code>vars</code> <code>list</code> <p>List of arguments</p> required <code>domain_shape</code> <code>str</code> <p>Name of domain type</p> required Source code in <code>openterrace/domains/sphere_1d.py</code> <pre><code>def validate_input(vars, domain_shape):\n    \"\"\"Validates input arguments.\n\n    Args:\n        vars (list): List of arguments\n        domain_shape (str): Name of domain type\n    \"\"\"\n\n    required = ['n','R']\n    for var in required:\n        if not var in vars:\n            raise Exception(\"Keyword \\'\"+var+\"\\' not specified for domain of type \\'\"+domain_shape+\"\\'\")\n</code></pre>"},{"location":"user-guide/fluid_substances/air/","title":"Air","text":"<p>Data for atmospheric air.</p> <p>Reference 1: Eric W. Lemmon, Richard T. Jacobsen, Steven G. Penoncello, and Daniel G. Friend. Thermodynamic Properties of Air and Mixtures of Nitrogen, Argon, and Oxygen from 60 to 2000 K at Pressures to 2000 MPa. J. Phys. Chem. Ref. Data, 29(3):331\u2013385, 2000. doi:10.1063/1.1285884. Reference 2: E. W. Lemmon and R. T Jacobsen. Viscosity and Thermal Conductivity Equations for Nitrogen, Oxygen, Argon, and Air. Int. J. Thermophys., 25(1):21\u201369, 2004. doi:10.1023/B:IJOT.0000022327.04529.f3.</p>"},{"location":"user-guide/fluid_substances/air/#fluid_substances.air.Pr","title":"<code>Pr(h, p=None)</code>","text":"<p>Dynamic viscosity as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Prandtl number</p> Source code in <code>openterrace/fluid_substances/air.py</code> <pre><code>def Pr(h:float, p:float=None) -&gt; float:\n    \"\"\"Dynamic viscosity as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Prandtl number\n    \"\"\"\n    return 2.71884293e-25*h**4 - 1.12907428e-18*h**3 + 1.70869490e-12*h**2 - 1.05637297e-06*h + 9.25357206e-01\n</code></pre>"},{"location":"user-guide/fluid_substances/air/#fluid_substances.air.T","title":"<code>T(h, p=None)</code>","text":"<p>Temperature as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Temperature in kelvin</p> Source code in <code>openterrace/fluid_substances/air.py</code> <pre><code>def T(h:float, p:float=None) -&gt; float:\n    \"\"\"Temperature as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Temperature in kelvin\n    \"\"\"\n    return 9.41315014e-04*h - 9.47094244e+01\n</code></pre>"},{"location":"user-guide/fluid_substances/air/#fluid_substances.air.cp","title":"<code>cp(h, p=None)</code>","text":"<p>Specific heat capacity as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Specific heat capacity in J/(kg K)</p> Source code in <code>openterrace/fluid_substances/air.py</code> <pre><code>def cp(h:float, p:float=None) -&gt; float:\n    \"\"\"Specific heat capacity as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Specific heat capacity in J/(kg K)\n    \"\"\"\n    return -3.31926950e-16*h**3 + 8.48767643e-10*h**2 - 4.95535470e-04*h + 1.08860162e+03\n</code></pre>"},{"location":"user-guide/fluid_substances/air/#fluid_substances.air.h","title":"<code>h(T)</code>","text":"<p>Mass specific enthalpy as function of temperature at 1 atm (fit valid between 273.15 K to 1000 K).</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>float</code> <p>Temperature in K</p> required <p>Returns:</p> Type Description <code>float</code> <p>Mass specific enthalpy in J/kg</p> Source code in <code>openterrace/fluid_substances/air.py</code> <pre><code>def h(T:float) -&gt; float:\n    \"\"\"Mass specific enthalpy as function of temperature at 1 atm (fit valid between 273.15 K to 1000 K).\n\n    Args:\n        T (float): Temperature in K\n\n    Returns:\n        Mass specific enthalpy in J/kg\n    \"\"\"\n    return 1062.3436205*T + 100613.952812\n</code></pre>"},{"location":"user-guide/fluid_substances/air/#fluid_substances.air.k","title":"<code>k(h, p=None)</code>","text":"<p>Thermal conductivity as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Thermal conductivity in W/(m K)</p> Source code in <code>openterrace/fluid_substances/air.py</code> <pre><code>def k(h:float, p:float=None) -&gt; float:\n    \"\"\"Thermal conductivity as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Thermal conductivity in W/(m K)\n    \"\"\"\n    return -1.91985865e-14*h**2 + 8.53813872e-08*h - 6.32545058e-03\n</code></pre>"},{"location":"user-guide/fluid_substances/air/#fluid_substances.air.mu","title":"<code>mu(h, p=None)</code>","text":"<p>Dynamic viscosity as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Dynamic viscosity in kg/(m s)</p> Source code in <code>openterrace/fluid_substances/air.py</code> <pre><code>def mu(h:float, p:float=None) -&gt; float:\n    \"\"\"Dynamic viscosity as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Dynamic viscosity in kg/(m s)\n    \"\"\"\n    return -1.49118910e-17*h**2 + 5.64575734e-11*h - 2.65149023e-06\n</code></pre>"},{"location":"user-guide/fluid_substances/air/#fluid_substances.air.rho","title":"<code>rho(h, p=None)</code>","text":"<p>Density as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Density in kg/m^3</p> Source code in <code>openterrace/fluid_substances/air.py</code> <pre><code>def rho(h:float, p:float=None) -&gt; float:\n    \"\"\"Density as function of mass specific enthalpy at 1 atm (fit valid between 273.15 K to 1000 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Density in kg/m^3\n    \"\"\"\n    return -2.99101902e-18*h**3 + 8.99511511e-12*h**2 - 9.18059393e-06*h + 3.68623992e+00\n</code></pre>"},{"location":"user-guide/fluid_substances/nak2278/","title":"Nak2278","text":"<p>Data for liquid mixture of sodium (22%) and potassium (78%).</p> <p>Reference 1: https://www-pub.iaea.org/MTCD/publications/PDF/IAEA-THPH_web.pdf</p>"},{"location":"user-guide/fluid_substances/nak2278/#fluid_substances.nak2278.Pr","title":"<code>Pr(h, p=None)</code>","text":"<p>Prandtl number as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Prandtl number</p> Source code in <code>openterrace/fluid_substances/nak2278.py</code> <pre><code>def Pr(h:float, p:float=None) -&gt; float:\n    \"\"\"Prandtl number as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Prandtl number\n    \"\"\"\n    return -125.757554730265e-021*h**3 + 193.669437204884e-015*h**2 - 105.180849961483e-009*h + 25.4815572990799e-003\n</code></pre>"},{"location":"user-guide/fluid_substances/nak2278/#fluid_substances.nak2278.T","title":"<code>T(h, p=None)</code>","text":"<p>Temperature as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Temperature in kelvin</p> Source code in <code>openterrace/fluid_substances/nak2278.py</code> <pre><code>def T(h:float, p:float=None) -&gt; float:\n    \"\"\"Temperature as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Temperature in kelvin\n    \"\"\"\n    return 1.13586014618602e-003*h + 258.145301176596e+000\n</code></pre>"},{"location":"user-guide/fluid_substances/nak2278/#fluid_substances.nak2278.cp","title":"<code>cp(h, p=None)</code>","text":"<p>Specific heat capacity as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Specific heat capacity in J/(kg K)</p> Source code in <code>openterrace/fluid_substances/nak2278.py</code> <pre><code>def cp(h:float, p:float=None) -&gt; float:\n    \"\"\"Specific heat capacity as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Specific heat capacity in J/(kg K)\n    \"\"\"\n    return 474.869992698948e-012*h**2 - 455.554064632647e-006*h**1 + 980.401559485058e+000\n</code></pre>"},{"location":"user-guide/fluid_substances/nak2278/#fluid_substances.nak2278.h","title":"<code>h(T)</code>","text":"<p>Mass specific enthalpy as function of temperature at 1 atm (fit valid between 473.15 K to 873.15 K).</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>float</code> <p>Temperature in K</p> required <p>Returns:</p> Type Description <code>float</code> <p>Specific enthalpy in J/kg</p> Source code in <code>openterrace/fluid_substances/nak2278.py</code> <pre><code>def h(T:float) -&gt; float:\n    \"\"\"Mass specific enthalpy as function of temperature at 1 atm (fit valid between 473.15 K to 873.15 K).\n\n    Args:\n        T (float): Temperature in K\n\n    Returns:\n        Specific enthalpy in J/kg\n    \"\"\"\n    return 880.390075624882e+000*T - 227.268561225071e+003\n</code></pre>"},{"location":"user-guide/fluid_substances/nak2278/#fluid_substances.nak2278.k","title":"<code>k(h, p=None)</code>","text":"<p>Thermal conductivity as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Thermal conductivity in W/(m K)</p> Source code in <code>openterrace/fluid_substances/nak2278.py</code> <pre><code>def k(h:float, p:float=None) -&gt; float:\n    \"\"\"Thermal conductivity as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Thermal conductivity in W/(m K)\n    \"\"\"\n    return -26.2590503127977e-012*h**2 + 21.6513924586817e-006*h + 21.5505803714445e+000\n</code></pre>"},{"location":"user-guide/fluid_substances/nak2278/#fluid_substances.nak2278.mu","title":"<code>mu(h, p=None)</code>","text":"<p>Dynamic viscosity as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Dynamic viscosity in kg/(m*s)</p> Source code in <code>openterrace/fluid_substances/nak2278.py</code> <pre><code>def mu(h:float, p:float=None) -&gt; float:\n    \"\"\"Dynamic viscosity as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Dynamic viscosity in kg/(m*s)\n    \"\"\"\n    return -2.72327193790784e-021*h**3 + 4.15934757530690e-015*h**2 - 2.31891771547815e-009*h + 625.420290036714e-006\n</code></pre>"},{"location":"user-guide/fluid_substances/nak2278/#fluid_substances.nak2278.rho","title":"<code>rho(h, p=None)</code>","text":"<p>Density as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Density in kg/m^3</p> Source code in <code>openterrace/fluid_substances/nak2278.py</code> <pre><code>def rho(h:float, p:float=None) -&gt; float:\n    \"\"\"Density as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Density in kg/m^3\n    \"\"\"\n    return -267.073587305967e-006*h + 868.620522246425e+000\n</code></pre>"},{"location":"user-guide/fluid_substances/water/","title":"Water","text":"<p>Data for water.</p> <p>Reference 1: W. Wagner and A. Pru\u00df. The IAPWS Formulation 1995 for the Thermodynamic Properties of Ordinary Water Substance for General and Scientific Use. J. Phys. Chem. Ref. Data, 31:387\u2013535, 2002. doi:10.1063/1.1461829. Reference 2: M. L. Huber, R. A. Perkins, D. G. Friend, J. V. Sengers, M. J. Assael, I. N. Metaxa, K. Miyagawa, R. Hellmann, and E. Vogel. New International Formulation for the Thermal Conductivity of H2O. J. Phys. Chem. Ref. Data, 41(3):033102\u20131:23, 2012. doi:10.1063/1.4738955. Reference 3: M. L. Huber, R. A. Perkins, A. Laesecke, D. G. Friend, J. V. Sengers, M. J Assael, I. M. Metaxa, E. Vogel, R. Mare\u0161, and K. Miyagawa. New International Formulation for the Viscosity of H2O. J. Phys. Chem. Ref. Data, 38(2):101\u2013125, 2009. doi:10.1063/1.3088050.</p>"},{"location":"user-guide/fluid_substances/water/#fluid_substances.water.Pr","title":"<code>Pr(h, p=None)</code>","text":"<p>Prandtl number as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Prandtl number</p> Source code in <code>openterrace/fluid_substances/water.py</code> <pre><code>def Pr(h:float, p:float=None) -&gt; float:\n    \"\"\"Prandtl number as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Prandtl number\n    \"\"\"\n    return 2.76464299e-10*h**2 - 9.03954950e-05*h + 1.30070174e+01\n</code></pre>"},{"location":"user-guide/fluid_substances/water/#fluid_substances.water.T","title":"<code>T(h, p=None)</code>","text":"<p>Temperature as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Temperature in kelvin</p> Source code in <code>openterrace/fluid_substances/water.py</code> <pre><code>def T(h:float, p:float=None) -&gt; float:\n    \"\"\"Temperature as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Temperature in kelvin\n    \"\"\"\n    return 2.38859172e-04*h + 2.73107340e+02\n</code></pre>"},{"location":"user-guide/fluid_substances/water/#fluid_substances.water.cp","title":"<code>cp(h, p=None)</code>","text":"<p>Specific heat capacity as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Specific heat capacity in J/(kg K)</p> Source code in <code>openterrace/fluid_substances/water.py</code> <pre><code>def cp(h:float, p:float=None) -&gt; float:\n    \"\"\"Specific heat capacity as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Specific heat capacity in J/(kg K)\n    \"\"\"\n    return -1.91167239e-15*h**3 + 1.96122501e-09*h**2 - 4.90430569e-04*h**1 + 4.21421348e+03    \n</code></pre>"},{"location":"user-guide/fluid_substances/water/#fluid_substances.water.h","title":"<code>h(T)</code>","text":"<p>Mass specific enthalpy as function of temperature at 1 atm (fit valid between 273 K to 373 K).</p> <p>Parameters:</p> Name Type Description Default <code>T</code> <code>float</code> <p>Temperature in K</p> required <p>Returns:</p> Type Description <code>float</code> <p>Specific enthalpy in J/kg</p> Source code in <code>openterrace/fluid_substances/water.py</code> <pre><code>def h(T:float) -&gt; float:\n    \"\"\"Mass specific enthalpy as function of temperature at 1 atm (fit valid between 273 K to 373 K).\n\n    Args:\n        T (float): Temperature in K\n\n    Returns:\n        Specific enthalpy in J/kg\n    \"\"\"\n    return 4186.56437769*T - 1143381.31556279\n</code></pre>"},{"location":"user-guide/fluid_substances/water/#fluid_substances.water.k","title":"<code>k(h, p=None)</code>","text":"<p>Thermal conductivity as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Thermal conductivity in W/(m K)</p> Source code in <code>openterrace/fluid_substances/water.py</code> <pre><code>def k(h:float, p:float=None) -&gt; float:\n    \"\"\"Thermal conductivity as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Thermal conductivity in W/(m K)\n    \"\"\"\n    return -5.45934292e-13*h**2 + 5.09161571e-07*h + 5.58152818e-01\n</code></pre>"},{"location":"user-guide/fluid_substances/water/#fluid_substances.water.mu","title":"<code>mu(h, p=None)</code>","text":"<p>Dynamic viscosity as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Dynamic viscosity in kg/(m*s)</p> Source code in <code>openterrace/fluid_substances/water.py</code> <pre><code>def mu(h:float, p:float=None) -&gt; float:\n    \"\"\"Dynamic viscosity as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Dynamic viscosity in kg/(m*s)\n    \"\"\"\n    return 1.05996810e-14*h**2 - 7.39076316e-09*h + 1.61251851e-03\n</code></pre>"},{"location":"user-guide/fluid_substances/water/#fluid_substances.water.rho","title":"<code>rho(h, p=None)</code>","text":"<p>Density as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).</p> <p>Parameters:</p> Name Type Description Default <code>h</code> <code>float</code> <p>Specific enthalpy in J/kg</p> required <code>p</code> <code>float</code> <p>Pressure in Pa</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Density in kg/m^3</p> Source code in <code>openterrace/fluid_substances/water.py</code> <pre><code>def rho(h:float, p:float=None) -&gt; float:\n    \"\"\"Density as function of mass specific enthalpy at 1 atm (fit valid between 273 K to 373 K).\n\n    Args:\n        h (float): Specific enthalpy in J/kg\n        p (float): Pressure in Pa\n\n    Returns:\n        Density in kg/m^3\n    \"\"\"\n    return -2.01577822e-10*h**2 - 1.84350638e-05*h + 1.00080945e+03\n</code></pre>"},{"location":"user-guide/verification-and-validation/validation/","title":"Validation studies","text":"<p>To be added...</p>"},{"location":"user-guide/verification-and-validation/verification/","title":"Verification studies","text":"<p>The OpenTerrace code is tested against known analytical solution in limiting cases. The following presents such code verification results. These are run automatically as part of the automated tests using GitHub actions.</p>"},{"location":"user-guide/verification-and-validation/verification/#pure-diffusion","title":"Pure diffusion","text":""},{"location":"user-guide/verification-and-validation/verification/#pure-advection","title":"Pure advection","text":"<p>To be added...</p>"}]}